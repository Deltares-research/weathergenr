#' Filter and Sample WARM Simulations by Statistical and Spectral Criteria
#'
#' Filters synthetic time series generated by WARM (Wavelet Autoregressive Modeling)
#' based on statistical moments (mean, standard deviation, min, max) and spectral
#' properties (global wavelet power spectrum). Selects realizations that match
#' observed data within specified tolerance bounds, then samples a subset for
#' final output.
#'
#' @param series.obs Numeric vector. Observed annual time series (length = years).
#' @param series.sim Numeric matrix. Simulated time series from WARM
#'   (nrow = years, ncol = realizations).
#' @param power.obs Numeric vector. Observed global wavelet power spectrum.
#' @param power.sim Numeric matrix. Simulated global wavelet spectra
#'   (nrow = periods, ncol = realizations).
#' @param power.period Numeric vector. Periods (years) corresponding to power spectra.
#' @param power.signif Numeric vector. Significance thresholds for power spectra
#'   at each period.
#' @param sample.num Integer. Number of realizations to sample from filtered set
#'   for final output (default: 5).
#' @param seed Integer or NULL. Random seed for reproducible sampling (default: NULL).
#' @param save.plots Logical. Whether to save diagnostic plots to disk (default: TRUE).
#' @param save.series Logical. Whether to write selected series to CSV files
#'   (default: TRUE).
#' @param output.path Character. Directory path for saving plots and CSV files.
#'   Created if it doesn't exist.
#' @param padding Logical. Whether to include adjacent periods (plus or minus 1) around
#'   significant periods in spectral filtering (default: TRUE).
#' @param bounds Named list. Tolerance bounds for filtering criteria:
#'   \describe{
#'     \item{mean}{Relative tolerance for mean (default: 0.1 = 10 percent)}
#'     \item{sd}{Relative tolerance for standard deviation (default: 0.2 = 20 percent)}
#'     \item{min}{Relative tolerance for minimum value (default: 0.2 = 20 percent)}
#'     \item{max}{Relative tolerance for maximum value (default: 0.2 = 20 percent)}
#'     \item{sig.thr}{Lower bound for significant period power as fraction of
#'       observed power (default: 0.5 = 50 percent)}
#'     \item{nsig.thr}{Upper bound for non-significant period power as multiple
#'       of significance threshold (default: 1.5 = 150 percent)}
#'   }
#' @param plot.prefix Character. Prefix for plot filenames (default: "warm").
#' @param series.units Character. Units label for y-axis in time series plots
#'   (default: "mm/year").
#' @param series.conversion Numeric. Conversion factor for plotting. Use 365 to
#'   convert daily values to annual (default: 365). Set to 1 if data is already
#'   in annual units.
#'
#' @return A list with four elements:
#'   \describe{
#'     \item{subsetted}{Numeric matrix containing all realizations that passed
#'       all filtering criteria (ncol = number that passed)}
#'     \item{sampled}{Numeric matrix of randomly sampled realizations from the
#'       filtered set (ncol = sample.num or fewer if insufficient realizations passed)}
#'     \item{n_filtered}{Integer. Number of realizations that passed all filters}
#'     \item{filter_summary}{Data frame summarizing the number and percentage of
#'       realizations passing each individual filter}
#'   }
#'
#' @details
#' The function implements a multi-stage filtering process:
#'
#' 1. Statistical Filtering: Realizations are checked against tolerance bounds
#'    for mean, standard deviation, minimum, and maximum values relative to observed data.
#'
#' 2. Spectral Filtering: For periods identified as significant in observed data,
#'    realizations must have:
#'    (a) At least one significant period exceeding the significance threshold
#'    (b) All significant periods within specified bounds of observed power
#'    (c) Non-significant periods remaining below threshold
#'
#' 3. Fallback: If no realizations pass all filters, the power spectrum
#'    constraint is relaxed and only statistical criteria are applied.
#'
#' 4. Sampling: From the filtered set, a random sample of size sample.num
#'    is drawn for final output.
#'
#' If save.plots = TRUE, four diagnostic plots are generated:
#' - Spectral match for all filtered realizations
#' - Spectral match for sampled realizations
#' - Violin plots of statistical criteria with sampled realizations highlighted
#' - Time series plot comparing observed data to sampled realizations
#'
#' @references
#' Steinschneider, S. and Lall, U. (2015). A hierarchical Bayesian regional model
#' for nonstationary precipitation extremes in Northern California conditioned on
#' tropical moisture exports. \emph{Water Resources Research}, 51(3), 1472-1492.
#'
#' @examples
#' \dontrun{
#' # After generating WARM simulations
#' filtered <- filter_warm_simulations(
#'   series.obs = observed_annual,
#'   series.sim = warm_output,
#'   power.obs = wavelet_results$GWS,
#'   power.sim = simulated_power_spectra,
#'   power.period = wavelet_results$period,
#'   power.signif = wavelet_results$GWS_signif,
#'   sample.num = 10,
#'   seed = 123,
#'   output.path = "results/warm_filtering",
#'   bounds = list(
#'     mean = 0.1,    # +/- 10% for mean
#'     sd = 0.15,     # +/- 15% for standard deviation
#'     min = 0.2,     # +/- 20% for minimum
#'     max = 0.2,     # +/- 20% for maximum
#'     sig.thr = 0.5, # Significant periods >= 50% of observed
#'     nsig.thr = 1.5 # Non-significant periods <= 150% of threshold
#'   )
#' )
#'
#' # Access results
#' cat("Realizations passing filters:", filtered$n_filtered, "\n")
#' print(filtered$filter_summary)
#'
#' # Use sampled realizations for further analysis
#' selected_traces <- filtered$sampled
#' }
#'
#' @seealso
#' \code{\link{wavelet_arima}} for generating WARM simulations,
#' \code{\link{wavelet_spectral_analysis}} for computing power spectra

#' @export
#' @import ggplot2
#' @importFrom dplyr tibble mutate summarize group_by left_join select filter
#' @importFrom tidyr gather pivot_wider pivot_longer
filter_warm_simulations <- function(series.obs = NULL,
                                    series.sim = NULL,
                                    power.obs = NULL,
                                    power.sim = NULL,
                                    power.period = NULL,
                                    power.signif = NULL,
                                    sample.num = 5,
                                    seed = NULL,
                                    save.plots = TRUE,
                                    save.series = TRUE,
                                    output.path = NULL,
                                    padding = TRUE,
                                    bounds = list(
                                      mean = 0.1, sd = 0.2, min = 0.2, max = 0.2,
                                      sig.thr = 0.5, nsig.thr = 1.5
                                    ),
                                    plot.prefix = "warm",
                                    series.units = "mm/year",
                                    series.conversion = 365) {

  # ===========================================================================
  # Input Validation
  # ===========================================================================

  if (is.null(series.obs) || !is.numeric(series.obs)) {
    stop("'series.obs' must be a numeric vector.", call. = FALSE)
  }

  if (is.null(series.sim) || !is.numeric(series.sim) || !is.matrix(series.sim)) {
    stop("'series.sim' must be a numeric matrix.", call. = FALSE)
  }

  if (is.null(power.obs) || !is.numeric(power.obs)) {
    stop("'power.obs' must be a numeric vector.", call. = FALSE)
  }

  if (is.null(power.sim) || !is.numeric(power.sim) || !is.matrix(power.sim)) {
    stop("'power.sim' must be a numeric matrix.", call. = FALSE)
  }

  if (is.null(power.period) || !is.numeric(power.period)) {
    stop("'power.period' must be a numeric vector.", call. = FALSE)
  }

  if (is.null(power.signif) || !is.numeric(power.signif)) {
    stop("'power.signif' must be a numeric vector.", call. = FALSE)
  }

  if (!is.numeric(sample.num) || sample.num < 1) {
    stop("'sample.num' must be a positive integer.", call. = FALSE)
  }

  if (length(power.period) != length(power.signif)) {
    stop(
      "'power.period' and 'power.signif' must have the same length.",
      call. = FALSE
    )
  }

  if (ncol(series.sim) != ncol(power.sim)) {
    stop(
      "'series.sim' and 'power.sim' must have the same number of realizations.",
      call. = FALSE
    )
  }

  if (save.plots && is.null(output.path)) {
    stop("'output.path' must be specified when save.plots = TRUE.", call. = FALSE)
  }

  if (save.series && is.null(output.path)) {
    stop("'output.path' must be specified when save.series = TRUE.", call. = FALSE)
  }

  logger::log_info("[WARM] Filter criteria:")
  logger::log_info("[WARM] - Mean: {bounds$mean * 100}%")
  logger::log_info("[WARM] - Standard Deviation: {bounds$sd * 100}%")
  logger::log_info("[WARM] - Annual minima: {bounds$min * 100}%")
  logger::log_info("[WARM] - Annual maxima: {bounds$max * 100}%")

  # ===========================================================================
  # Setup
  # ===========================================================================

  n_realizations <- ncol(series.sim)
  sim.year.num <- nrow(series.sim)

  # Create output directory if needed
  if (!is.null(output.path) && !dir.exists(output.path)) {
    dir.create(output.path, recursive = TRUE, showWarnings = FALSE)
  }

  # Workaround for rlang warnings
  sim <- value <- par <- type <- variable <- y <- x <- obs <- NULL

  # ===========================================================================
  # RNG State Management
  # ===========================================================================

  if (!is.null(seed)) {
    if (exists(".Random.seed", envir = .GlobalEnv)) {
      old_seed <- .Random.seed
      has_seed <- TRUE
    } else {
      has_seed <- FALSE
    }

    on.exit({
      if (has_seed) {
        .Random.seed <<- old_seed
      }
    }, add = TRUE)

    set.seed(seed)
  }

  # ===========================================================================
  # Vectorized Statistics Computation
  # ===========================================================================

  # Observed statistics (computed once)
  obs_mean <- mean(series.obs)
  obs_sd <- sd(series.obs)
  obs_min <- min(series.obs)
  obs_max <- max(series.obs)

  # Simulated statistics (vectorized)
  sim_means <- colMeans(series.sim)
  sim_sds <- apply(series.sim, 2, sd)
  sim_mins <- apply(series.sim, 2, min)
  sim_maxs <- apply(series.sim, 2, max)

  # Compute relative differences (vectorized)
  epsilon <- 1e-10

  rel_diff_mean <- if (abs(obs_mean) < epsilon) {
    rep(0, n_realizations)
  } else {
    (sim_means - obs_mean) / obs_mean
  }

  rel_diff_sd <- if (abs(obs_sd) < epsilon) {
    rep(0, n_realizations)
  } else {
    (sim_sds - obs_sd) / obs_sd
  }

  rel_diff_min <- if (abs(obs_min) < epsilon) {
    rep(0, n_realizations)
  } else {
    (sim_mins - obs_min) / obs_min
  }

  rel_diff_max <- if (abs(obs_max) < epsilon) {
    rep(0, n_realizations)
  } else {
    (sim_maxs - obs_max) / obs_max
  }

  # ===========================================================================
  # Fast Period Identification
  # ===========================================================================

  periods_sig <- which(power.obs > power.signif)

  if (length(periods_sig) == 0) {
    warning("No significant periods found in observed data.", call. = FALSE)
  }

  # Efficient padding
  if (isTRUE(padding) && length(periods_sig) > 0) {
    n_periods <- length(power.signif)
    periods_sig <- unique(sort(c(
      pmax(periods_sig - 1, 1),
      periods_sig,
      pmin(periods_sig + 1, n_periods)
    )))
  }

  periods_nonsig <- setdiff(seq_along(power.signif), periods_sig)
  periods_nonsig <- periods_nonsig[periods_nonsig <= nrow(power.sim)]

  # ===========================================================================
  # Vectorized Filtering
  # ===========================================================================

  # Pre-allocate logical matrix
  filter_passed <- matrix(TRUE, nrow = n_realizations, ncol = 5)
  colnames(filter_passed) <- c("mean", "sd", "min", "max", "power")

  # Vectorized filters
  if (!is.null(bounds$mean)) {
    filter_passed[, "mean"] <- abs(rel_diff_mean) < bounds$mean
  }

  if (!is.null(bounds$sd)) {
    filter_passed[, "sd"] <- abs(rel_diff_sd) < bounds$sd
  }

  if (!is.null(bounds$min)) {
    filter_passed[, "min"] <- abs(rel_diff_min) < bounds$min
  }

  if (!is.null(bounds$max)) {
    filter_passed[, "max"] <- abs(rel_diff_max) < bounds$max
  }

  # ===========================================================================
  # Vectorized Power Spectrum Filter
  # ===========================================================================

  if (!is.null(bounds$sig.thr) && length(periods_sig) > 0) {

    power_signif_max <- 10

    # Extract relevant submatrices once
    power_sim_sig <- power.sim[periods_sig, , drop = FALSE]
    power_signif_sig <- power.signif[periods_sig]
    power_obs_sig <- power.obs[periods_sig]

    # Vectorized condition checks

    # Condition 1: At least one significant period exceeds threshold
    has_signal <- colSums(power_sim_sig > matrix(
      power_signif_sig,
      nrow = length(periods_sig),
      ncol = n_realizations)) > 0

    # Condition 2: All significant periods within bounds
    lower_bound <- power_obs_sig * bounds$sig.thr
    upper_bound <- power_obs_sig * power_signif_max

    within_lower <- power_sim_sig > matrix(
      lower_bound,
      nrow = length(periods_sig),
      ncol = n_realizations)

    within_upper <- power_sim_sig < matrix(
      upper_bound,
      nrow = length(periods_sig),
      ncol = n_realizations)

    within_bounds <- colSums(within_lower & within_upper) == length(periods_sig)

    # Condition 3: Non-significant periods remain below threshold
    if (length(periods_nonsig) > 0) {
      power_sim_nonsig <- power.sim[periods_nonsig, , drop = FALSE]
      power_signif_nonsig <- power.signif[periods_nonsig]

      nonsig_threshold <- matrix(
        power_signif_nonsig * bounds$nsig.thr,
        nrow = length(periods_nonsig),
        ncol = n_realizations)

      nonsig_ok <- colSums(power_sim_nonsig < nonsig_threshold) == length(periods_nonsig)
    } else {
      nonsig_ok <- rep(TRUE, n_realizations)
    }

    # Combined power filter
    filter_passed[, "power"] <- has_signal & within_bounds & nonsig_ok
  }

  # ===========================================================================
  # Fast Combined Filtering
  # ===========================================================================

  sub_clim <- which(rowSums(filter_passed) == ncol(filter_passed))

  # ===========================================================================
  # Sampling with Fallback
  # ===========================================================================

  relaxation_level <- "none"

  # 1. Full filter (stats + power)
  sub_clim <- which(rowSums(filter_passed) == ncol(filter_passed))

  # 2. Drop power filter
  if (length(sub_clim) == 0) {
    warning("No realizations passed all filters. Dropping power constraint.", call. = FALSE)
    relaxation_level <- "no_power"
    sub_clim <- which(rowSums(filter_passed[, 1:4, drop = FALSE]) == 4)
  }

  # 3. Drop most restrictive stat filter (SD first)
  if (length(sub_clim) == 0) {
    warning("No realizations after power relaxation. Dropping SD constraint.", call. = FALSE)
    relaxation_level <- "no_power_no_sd"
    sub_clim <- which(
      filter_passed[, "mean"] &
        filter_passed[, "min"] &
        filter_passed[, "max"]
    )
  }

  # 4. Drop min/max (keep mean only)
  if (length(sub_clim) == 0) {
    warning("Dropping min/max constraints. Retaining mean only.", call. = FALSE)
    relaxation_level <- "mean_only"
    sub_clim <- which(filter_passed[, "mean"])
  }

  # 5. Absolute fallback: closest by mean deviation
  if (length(sub_clim) == 0) {
    warning("No filters satisfied. Selecting closest realizations by mean deviation.", call. = FALSE)
    relaxation_level <- "closest_mean"
    sub_clim <- order(abs(rel_diff_mean))[seq_len(min(sample.num, n_realizations))]
  }

  # Final sampling
  n_sampled <- min(sample.num, length(sub_clim))
  sub_sample <- sample(sub_clim, n_sampled)

  # ===========================================================================
  # Efficient Reporting
  # ===========================================================================

  filter_summary <- data.frame(
    filter = colnames(filter_passed),
    n_passed = colSums(filter_passed),
    pct_passed = colSums(filter_passed) / n_realizations * 100,
    relaxation_level = relaxation_level,
    stringsAsFactors = FALSE
  )

  logger::log_info("[WARM] Filtering summary:")
  logger::log_info("[WARM] - Total realizations: {n_realizations}")
  logger::log_info("[WARM] - Passed all filters: {length(sub_clim)} ({round(length(sub_clim)/n_realizations*100, 1)}%)")
  logger::log_info("[WARM] - Sampled for output: {n_sampled}")

  # ===========================================================================
  # Conditional Plotting
  # ===========================================================================

  if (isTRUE(save.plots)) {

    suppressWarnings({

      # Pre-compute plot indices once
      pl <- min(length(power.period), nrow(power.sim))
      plr <- 5 * ceiling(power.period[pl] / 5)

      # Extract submatrices once
      power_period_plot <- power.period[seq_len(pl)]
      power_signif_plot <- power.signif[seq_len(pl)]
      power_obs_plot <- power.obs[seq_len(pl)]

      # Plot 1: All matching realizations
      p <- plot_global_wavelet_spectrum(
            power.period = power_period_plot,
            power.signif = power_signif_plot,
            power.obs = power_obs_plot,
            power.sim = power.sim[seq_len(pl), sub_clim, drop = FALSE]) +
            scale_x_continuous(breaks = seq(5, plr, 5),
              limits = c(0, plr), expand = c(0, 0))

      ggsave(file.path(output.path, paste0(plot.prefix, "_spectral_matching.png")),
        plot = p, width = 8, height = 6)

      # Plot 2: Sampled realizations only
      p <- plot_global_wavelet_spectrum(power.period = power_period_plot,
        power.signif = power_signif_plot,
        power.obs = power_obs_plot,
        power.sim = power.sim[seq_len(pl), sub_sample, drop = FALSE]) +
        scale_x_continuous(breaks = seq(5, plr, 5),
          limits = c(0, plr),
          expand = c(0, 0))

      ggsave(file.path(output.path, paste0(plot.prefix, "_spectral_sampled.png")),
        plot = p, width = 8, height = 6)

      # Plot 3: Statistics violin plots
      par_labels <- c(mean = "Mean", sd = "StDev", min = "Minimum", max = "Maximum")

      # Pre-allocate for efficiency
      n_stats <- 4
      stats_sim_plot <- data.frame(
        sim = rep(seq_len(n_realizations), times = n_stats),
        par = rep(c("mean", "sd", "min", "max"), each = n_realizations),
        value = c(rel_diff_mean, rel_diff_sd, rel_diff_min, rel_diff_max) * 100,
        stringsAsFactors = FALSE
      )

      stats_sim_plot$par <- factor(
        stats_sim_plot$par,
        levels = c("mean", "sd", "min", "max")
      )

      p3 <- ggplot(stats_sim_plot, aes(x = par, y = value)) +
        theme_bw() +
        geom_violin(color = "black", fill = "gray90") +
        facet_wrap(
          ~ par,
          scales = "free",
          nrow = 1,
          labeller = as_labeller(par_labels)
        ) +
        geom_hline(yintercept = 0, linewidth = 1, color = "blue") +
        geom_point(
          data = stats_sim_plot[stats_sim_plot$sim %in% sub_sample, ],
          size = 3,
          color = "white",
          fill = "black",
          shape = 21
        ) +
        scale_y_continuous(limits = c(-50, 50), breaks = seq(-50, 50, 25)) +
        labs(x = "", y = "Relative Difference (%)") +
        theme(
          axis.title.x = element_blank(),
          axis.text.x = element_blank(),
          axis.ticks.x = element_blank()
        )

      ggsave(
        file.path(output.path, paste0(plot.prefix, "_stats_sampled.png")),
        plot = p3,
        width = 8,
        height = 6
      )

      # Plot 4: Time series
      sim_subset <- series.sim[, sub_sample, drop = FALSE] * series.conversion

      # Build data frame efficiently
      df_sim_long <- data.frame(
        x = rep(seq_len(sim.year.num), times = n_sampled),
        variable = rep(paste0("rlz", seq_len(n_sampled)), each = sim.year.num),
        y = as.vector(sim_subset),
        stringsAsFactors = FALSE
      )

      df_obs <- data.frame(
        x = seq_along(series.obs),
        y = series.obs * series.conversion
      )

      p4 <- ggplot(df_sim_long, aes(x = x, y = y)) +
        theme_bw(base_size = 12) +
        geom_line(
          aes(group = variable),
          color = "gray50",
          alpha = 0.5
        ) +
        geom_line(data = df_obs, color = "blue", linewidth = 1) +
        scale_x_continuous(expand = c(0, 0)) +
        labs(y = series.units, x = "Serial year") +
        guides(color = "none")

      ggsave(
        file.path(output.path, paste0(plot.prefix, "_annual_series.png")),
        plot = p4,
        width = 8,
        height = 6
      )
    })
  }

  # ===========================================================================
  # Efficient CSV Writing
  # ===========================================================================

  if (isTRUE(save.series)) {
    utils::write.csv(
      series.sim[, sub_clim, drop = FALSE],
      file = file.path(output.path, paste0(plot.prefix, "_output_matching.csv")),
      row.names = FALSE
    )

    utils::write.csv(
      series.sim[, sub_sample, drop = FALSE],
      file = file.path(output.path, paste0(plot.prefix, "_output_sampled.csv")),
      row.names = FALSE
    )
  }

  # ===========================================================================
  # Return
  # ===========================================================================

  return(list(
    subsetted = series.sim[, sub_clim, drop = FALSE],
    sampled = series.sim[, sub_sample, drop = FALSE],
    n_filtered = length(sub_clim),
    filter_summary = filter_summary
  ))
}
