#' @title Generate Synthetic Gridded Weather Series
#'
#' @description
#' Generates synthetic weather time-series for grid cells using hybrid Wavelet Autoregressive Modeling and KNN resampling.
#'
#' @details
#' For detailed description of the methodology, see Steinschneider et al. (2013).
#' #'
#' @param weather.data A named list of data frames containing daily weather observations for each grid cell. Each data frame should have one column per weather variable (e.g., precipitation, temperature) and one row per day.
#' @param weather.date A vector of `Date` objects corresponding to the daily time series in `weather.data`. The same date vector should apply to all grid cells.
#' @param weather.grid A data frame describing the spatial layout of grid cells. Must include columns `id` (unique grid identifier starting from 1), `xind`, `yind` (index positions), and spatial coordinates `x`, `y`.
#' @param output.path File path to the directory where generated output files, such as figures and NetCDFs, will be saved.
#' @param variable.names A character vector of names of weather variables to be included in the simulation (e.g., `c("precip", "temp")`).
#' @param variable.labels Optional character vector of human-readable labels corresponding to `variable.names`. Defaults to `variable.names` if not provided.
#' @param variable.units Optional character vector specifying the units of each weather variable (e.g., `c("mm", "?C")`). If not provided, units will be left blank.
#' @param warm.variable Name of the weather variable used for Wavelet Autoregressive Modeling (WARM). Typically this is a low-frequency driver like precipitation. Defaults to `"precip"`.
#' @param warm.signif.level Significance level (between 0 and 1) for retaining low-frequency components during wavelet decomposition. Higher values retain fewer components.
#' @param warm.sample.num Number of annual time series realizations to generate using the WARM model prior to filtering with statistical criteria.
#' @param knn.sample.num Number of historical years to sample from using the K-nearest neighbor (KNN) method during daily weather reconstruction.
#' @param sim.year.start Integer indicating the first year of the synthetic weather time series (e.g., 2020).
#' @param sim.year.num Integer specifying the total number of years to generate in each synthetic weather realization.
#' @param realization.num Number of independent stochastic realizations (i.e., synthetic weather traces) to simulate.
#' @param month.start Integer indicating the first month of the hydrological (or water) year. Defaults to `1` (January).
#' @param warm.subset.criteria A named list of numeric thresholds used to filter annual time series generated by WARM, based on summary statistics such as `mean`, `sd`, `min`, `max`, `sig.thr`, and `nsig.thr`.
#' @param mc.wet.quantile Quantile threshold (between 0 and 1) defining "wet" days for Markov Chain state modeling. Days above this threshold are considered wet.
#' @param mc.extreme.quantile Quantile threshold (between 0 and 1) for identifying "extremely wet" days, used for refining Markov Chain transitions.
#' @param seed Optional integer used to initialize random number generation for reproducible results. If not provided, a random seed is chosen.
#' @param compute.parallel Logical; if `TRUE`, parallel processing is enabled for performance-intensive steps.
#' @param num.cores Integer specifying the number of CPU cores to use for parallel processing. If `NULL`, all available cores minus one are used.
#' @param dry.spell.change A numeric vector of length 12 specifying monthly adjustment factors for dry spell lengths (e.g., `1` = no change, `>1` = longer spells). Defaults to `rep(1, 12)`.
#' @param wet.spell.change A numeric vector of length 12 specifying monthly adjustment factors for wet spell lengths (e.g., `1` = no change, `>1` = longer spells). Defaults to `rep(1, 12)`.
#' @param save.rdata Logical; if `TRUE`, saves intermediate R objects to disk in `.RData` format for debugging or reuse.

#'
#' @return a list object with two elements
#'  \item{resampled}{data frame of the sampled dates for each synthetic trace}
#'  \item{dates}{a date vector corresponding to simulated dates}
#'
#' @export generateWeatherSeries
#' @import ggplot2
#' @import tidyr
#' @import patchwork
#' @import dplyr
#' @import logger
#' @importFrom dplyr mutate
generateWeatherSeries <- function(
    weather.data = NULL,
    weather.grid = NULL,
    weather.date = NULL,
    variable.names = NULL,
    variable.labels = NULL,
    variable.units = NULL,
    sim.year.num = NULL,
    sim.year.start = 2020,
    month.start = 1,
    realization.num = 5,
    warm.variable = "precip",
    warm.signif.level = 0.90,
    warm.sample.num = 5000,
    warm.subset.criteria = list(mean = 0.1, sd = 0.2, min = 0.3, max = 0.3, sig.thr = 0.5, nsig.thr = 1.5),
    knn.sample.num = 120,
    mc.wet.quantile = 0.3,
    mc.extreme.quantile = 0.8,
    dry.spell.change = rep(1, 12),
    wet.spell.change = rep(1, 12),
    output.path = tempdir(),
    seed = NULL,
    compute.parallel = FALSE,
    num.cores = NULL,
    save.rdata = FALSE) {
  start_time <- Sys.time()

  # Seed handling
  if (!is.null(seed)) {
    old_seed <- .Random.seed
    on.exit(
      {
        .Random.seed <<- old_seed
      },
      add = TRUE
    )
    set.seed(seed)
  }

  # Directory checks
  dir.create(output.path, recursive = TRUE, showWarnings = FALSE)
  plots_path <- file.path(output.path, "plots")
  dir.create(plots_path, recursive = TRUE, showWarnings = FALSE)

  # Validation checks
  stopifnot(is.list(weather.data), is.data.frame(weather.grid))

  # Workaround for rlang warning
  wyear <- month <- day <- year <- 0

  if (is.null(variable.labels)) variable.labels <- variable.names
  if (is.null(variable.units)) variable.units <- rep("", length(variable.names))

  # Number of grids
  grids <- weather.grid$id
  ngrids <- length(grids)

  if (compute.parallel == TRUE) {
    if (is.null(num.cores)) num.cores <- parallel::detectCores() - 1
    logger::log_info("\n[Initialize] Starting in parallel mode:")
    logger::log_info("[Initialize] Number of cores: {num.cores}")
  } else {
    logger::log_info("\n[Initialize] Starting in sequential mode")
  }

  # PREPARE DATA MATRICES ::::::::::::::::::::::::::::::::::::::::::::::::::::::
  logger::log_info("[Initialize] Randomization seed set to: {seed}")
  logger::log_info("[Initialize] Climate variables: {paste(variable.names, collapse = ', ')}")
  logger::log_info("[Initialize] Historical period: {weather.date[1]} to {weather.date[length(weather.date)]}")
  logger::log_info("[Initialize] Total number of grid cells: {ngrids}")

  # Historical dates
  year_seq <- as.numeric(format(weather.date, "%Y"))
  year_start <- year_seq[1]
  year_end <- year_seq[length(year_seq)]

  dates_d <- tibble(
    year = as.numeric(format(weather.date, "%Y")),
    wyear = getWaterYear(weather.date, month.start),
    month = as.numeric(format(weather.date, "%m")),
    day = as.numeric(format(weather.date, "%d"))
  ) %>%
    dplyr::filter(wyear >= year_start & wyear <= year_end) %>%
    mutate(date = as.Date(paste(wyear, month, day, sep = "-")), .before = 1) %>%
    mutate(dateo = as.Date(paste(year, month, day, sep = "-")), .before = 1)

  year.num <- length(unique(dates_d$wyear))
  wyear_index <- which(weather.date %in% dates_d$dateo)

  # Multivariate list of daily climate data
  climate_d <- lapply(1:ngrids, function(i) {
    weather.data[[i]][wyear_index, ] %>%
      select(all_of(variable.names)) %>%
      mutate(year = dates_d$wyear, .)
  })

  climate_d_aavg <- Reduce(`+`, climate_d) / ngrids

  # Multivariate list of annual climate data
  climate_a <- lapply(1:ngrids, function(i) {
    climate_d[[i]] %>%
      group_by(year) %>%
      summarize(across({{ variable.names }}, mean)) %>%
      ungroup() %>%
      suppressMessages()
  })

  # Area-averaged annual weather series
  climate_a_aavg <- Reduce(`+`, climate_a) / ngrids


  # Simulated dates
  if (is.null(sim.year.num)) sim.year.num <- year.num
  sim_year_end <- sim.year.start + sim.year.num

  date_sim <- seq(as.Date(paste(sim.year.start, "-1-01", sep = "")),
    as.Date(paste(sim_year_end, "-12-31", sep = "")),
    by = "day"
  )

  sim_dates_d <- tibble(
    year = as.numeric(format(date_sim, "%Y")),
    wyear = getWaterYear(date_sim, month.start),
    month = as.numeric(format(date_sim, "%m")),
    day = as.numeric(format(date_sim, "%d"))
  ) %>%
    filter(month != 2 | day != 29) %>%
    filter(wyear >= sim.year.start + 1 & wyear <= sim_year_end) %>%
    mutate(date = as.Date(paste(year, month, day, sep = "-")), .before = 1)

  # ::::::::::: ANNUAL TIME-SERIES GENERATION USING WARM ::::::::::::::::::::::::

  #####  Wavelet analysis on observed annual series
  warm_variable <- climate_a_aavg %>% pull({{ warm.variable }})

  # power spectra analysis of historical series
  warm_power <- waveletAnalysis(
    variable = warm_variable,
    signif.level = warm.signif.level, plot = TRUE, output.path = plots_path
  )

  # if there is low-frequency signal
  if (length(warm_power$signif_periods) > 0) {
    # wavelet decomposition of historical series
    wavelet_comps <- waveletDecompose(
      variable = warm_variable,
      signif.periods = warm_power$signif_periods,
      signif.level = warm.signif.level, plot = TRUE, output.path = plots_path
    )

    logger::log_info("[WARM] Significant low-frequency components detected: {length(wavelet_comps)-1}")
    logger::log_info("[WARM] Detected periodiocity (years): {paste(warm_power$signif_periods, collapse=", ")}")
    logger::log_info("[WARM] Generating {format(warm.sample.num, big.mark=", ")} annual traces")

    sim_annual <- waveletARIMA(
      wavelet.components = wavelet_comps,
      sim.year.num = sim.year.num, sim.num = warm.sample.num, seed = seed
    )

    # if there is no low frequency signal
  } else {
    logger::log_info("[WARM] No low-frequency signals detected")
    logger::log_info("[WARM] Generating {format(warm.sample.num, big.mark=", ")} annual traces")

    # Remove the mean from the component
    MEAN <- mean(warm_variable)

    MODEL <- forecast::auto.arima((warm_variable - MEAN),
      max.p = 2, max.q = 2, max.P = 0, max.Q = 0,
      stationary = TRUE, seasonal = FALSE
    )

    INTERCEPT <- ifelse(length(which(names(MODEL$coef) == "intercept")) > 0,
      as.vector(MODEL$coef)[which(names(MODEL$coef) == "intercept")], 0
    )

    sim_annual <- sapply(1:warm.sample.num, function(x) {
      set.seed(seed + x)
      stats::simulate(MODEL, sim.year.num, sd = sqrt(MODEL$sigma2))
    }) + INTERCEPT + MEAN
  }

  # wavelet analysis on simulated series
  sim_power <- sapply(1:warm.sample.num, function(x) {
    waveletAnalysis(sim_annual[, x], signif.level = warm.signif.level)$GWS
  })

  if (!length(warm_power$signif_periods > 0)) {
    warm.subset.criteria$sig.thr <- NULL
    warm.subset.criteria$nsig.thr <- NULL
  }

  # subsetting from generated warm series
  sim_annual_sub <- waveletARSubset(
    series.obs = warm_variable,
    series.sim = sim_annual,
    power.obs = warm_power$GWS,
    power.sim = sim_power,
    power.period = warm_power$GWS_period,
    power.signif = warm_power$GWS_signif,
    sample.num = realization.num,
    output.path = plots_path,
    bounds = warm.subset.criteria,
    seed = seed,
    save.plots = TRUE,
    save.series = FALSE
  )

  logger::log_info("[WARM] Subset bounds: {paste(names(warm.subset.criteria), unlist(warm.subset.criteria), sep = '=', collapse = ', ')}")
  logger::log_info("[WARM] {ncol(sim_annual_sub$subsetted)} traces meet criteria")
  logger::log_info("[WARM] Sampling {ncol(sim_annual_sub$sampled)} traces for daily simulation")

  # ::::::::::: TEMPORAL & SPATIAL DISSAGGREGATION (knn & mc) :::::::::::::::::::

  logger::log_info("[KNN] Starting daily weather simulation using KNN + Markov Chain scheme")

  resampled_dates <- as_tibble(matrix(0,
    nrow = nrow(sim_dates_d),
    ncol = realization.num
  ), .name_repair = ~ paste0("rlz_", 1:realization.num))

  if (compute.parallel) {
    cl <- parallel::makeCluster(num.cores)
    doParallel::registerDoParallel(cl)
    `%d%` <- foreach::`%dopar%`
  } else {
    `%d%` <- foreach::`%do%`
  }

  resampled_ini <- foreach::foreach(n = seq_len(realization.num)) %d% {
    weathergenr::resampleDates(
      PRCP_FINAL_ANNUAL_SIM = sim_annual_sub$sampled[, n],
      ANNUAL_PRCP = warm_variable,
      PRCP = climate_d_aavg$precip,
      TEMP = climate_d_aavg$temp,
      START_YEAR_SIM = sim.year.start,
      k1 = n,
      ymax = sim.year.num,
      dates.d = dates_d,
      sim.dates.d = sim_dates_d,
      knn.annual.sample.num = knn.sample.num,
      dry.spell.change = dry.spell.change,
      wet.spell.change = wet.spell.change,
      YEAR_D = year_seq,
      month.start = month.start,
      wet.quantile = mc.wet.quantile,
      extreme.quantile = mc.extreme.quantile,
      seed = seed + n
    )
  }

  if (compute.parallel) parallel::stopCluster(cl)

  for (x in 1:ncol(resampled_dates)) {
    resampled_dates[, x] <- dates_d$dateo[match(resampled_ini[[x]], dates_d$date)]
  }

  utils::write.csv(sim_dates_d$date, file.path(output.path, "sim_dates.csv"), row.names = FALSE)
  utils::write.csv(resampled_dates, file.path(output.path, "resampled_dates.csv"), row.names = FALSE)

  if (save.rdata) {
    save.image(file = file.path(output.path, "swg_image.RData"))
    logger::log_info("[Output] Image saved to: {file.path(output.path, 'swg_image.RData')}")
  }

  logger::log_info("[Output] Results saved to: `", output.path, "`")
  logger::log_info("[Done] Simulation complete. Elapsed time: {Sys.time() - start_time} secs")

  return(list(resampled = resampled_dates, dates = sim_dates_d$date))
}
