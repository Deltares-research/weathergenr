#' @title Generate Synthetic Gridded Daily Weather Series
#'
#' @description
#' Generates stochastic daily weather time series for one or more grid cells by
#' combining:
#' \itemize{
#'   \item annual low-frequency variability simulated using Wavelet
#'         Autoregressive Modeling (WARM),
#'   \item annual K-nearest-neighbor (KNN) selection of historical years,
#'   \item a three-state (dry, wet, extreme) daily Markov chain for spell
#'         persistence,
#'   \item daily KNN resampling of precipitation and temperature anomalies.
#' }
#'
#' The function supports both calendar-year and water-year simulations.
#' The simulation regime is inferred automatically from \code{month.start}:
#' \itemize{
#'   \item \code{month.start == 1}: calendar-year simulation (January to December),
#'   \item \code{month.start != 1}: water-year simulation starting in the specified month.
#' }
#'
#' @details
#' The workflow consists of four main stages:
#'
#' \enumerate{
#'   \item \strong{Preprocessing of historical data:}
#'         Leap days are removed, water years are computed, and grid-cell data
#'         are aggregated to basin or domain averages for annual modeling.
#'
#'   \item \strong{Annual-scale simulation (WARM):}
#'         Low-frequency variability in the selected \code{warm.variable}
#'         (typically precipitation) is modeled using wavelet decomposition and
#'         autoregressive resampling. A subset of annual traces is retained based
#'         on user-defined summary-statistic criteria.
#'
#'   \item \strong{Daily disaggregation:}
#'         For each simulated year, historical years are selected using annual
#'         KNN matching. Daily weather is generated sequentially using a
#'         three-state Markov chain (dry, wet, extreme) and daily KNN resampling
#'         of anomalies.
#'
#'   \item \strong{Output construction:}
#'         For each realization, the function returns the sequence of resampled
#'         historical dates corresponding to the simulated daily weather.
#' }
#'
#' All simulations are performed on a 365-day calendar (no leap days).
#'
#' @param weather.data
#' A named list of data frames containing observed daily weather for each grid
#' cell. Each data frame must have one row per day (no leap days) and one column
#' per variable listed in \code{variables}.
#'
#' @param weather.grid
#' Data frame describing the spatial layout of grid cells. Must include at least
#' columns \code{id}, \code{xind}, \code{yind}, and spatial coordinates
#' \code{x}, \code{y}. Currently used for bookkeeping only.
#'
#' @param weather.date
#' Vector of class \code{Date} giving the observation dates corresponding to
#' \code{weather.data}. Must be identical for all grid cells.
#'
#' @param variables
#' Character vector giving the names of daily weather variables to simulate
#' (for example \code{c("precip", "temp")}).
#'
#' @param sim.year.start
#' Integer. First simulation year. Interpreted as a calendar year if
#' \code{month.start == 1}, otherwise as the first water year.
#'
#' @param sim.year.num
#' Integer. Number of years to simulate. If \code{NULL}, defaults to the number
#' of complete historical years available.
#'
#' @param realization.num
#' Integer. Number of independent stochastic realizations to generate.
#'
#' @param month.start
#' Integer in \code{1:12}. First month of the simulation year. Use \code{1} for
#' calendar-year simulations, or another month (for example \code{10}) for
#' water-year simulations.
#'
#' @param warm.variable
#' Character string giving the variable used for annual WARM modeling.
#' Typically a low-frequency driver such as precipitation.
#'
#' @param warm.signif.level
#' Numeric in (0, 1). Significance level used to retain low-frequency wavelet
#' components during WARM analysis.
#'
#' @param warm.sample.num
#' Integer. Number of candidate annual traces generated by the WARM model before
#' subsetting.
#'
#' @param warm.subset.criteria
#' Named list of numeric thresholds used to filter annual WARM traces based on
#' summary statistics (for example \code{mean}, \code{sd}, \code{min}, \code{max},
#' \code{sig.thr}, \code{nsig.thr}).
#'
#' @param knn.sample.num
#' Integer. Number of historical years sampled in the annual KNN step during
#' daily disaggregation.
#'
#' @param mc.wet.quantile
#' Numeric in (0, 1). Quantile used to define the wet-day threshold for the daily
#' Markov chain.
#'
#' @param mc.extreme.quantile
#' Numeric in (0, 1). Quantile used to define the extreme wet-day threshold for
#' the daily Markov chain.
#'
#' @param dry.spell.change
#' Numeric vector of length 12. Monthly adjustment factors controlling dry-spell
#' persistence in the Markov chain (\code{1} = no change).
#'
#' @param wet.spell.change
#' Numeric vector of length 12. Monthly adjustment factors controlling wet-spell
#' persistence in the Markov chain (\code{1} = no change).
#'
#' @param seed
#' Optional integer. Base random seed for reproducibility.
#'
#' @param compute.parallel
#' Logical. If \code{TRUE}, daily disaggregation across realizations is performed
#' in parallel.
#'
#' @param num.cores
#' Integer. Number of CPU cores to use for parallel execution. If \code{NULL},
#' all available cores minus one are used.
#'
#' @param output.path
#' Character string. Directory where diagnostic figures and intermediate CSV
#' files (simulated dates and resampled dates) are written.
#'
#' @return
#' A list with two elements:
#' \describe{
#'   \item{resampled}{A data frame with one column per realization, giving the
#'   resampled historical dates corresponding to each simulated day.}
#'   \item{dates}{A \code{Date} vector giving the simulated daily time axis
#'   (365-day calendar, no leap days).}
#' }
#'
#' @references
#' Steinschneider, S., Brown, C., & Lall, U. (2013).
#' Climate-informed water supply planning using wavelet-based stochastic
#' streamflow generators. \emph{Water Resources Research}.
#'
#' @export
#'
#' @import ggplot2
#' @import tidyr
#' @import patchwork
#' @import dplyr
#' @import logger
#' @importFrom dplyr mutate

generateWeatherSeries <- function(
    weather.data = NULL, #!!!
    weather.grid = NULL,
    weather.date = NULL, #!
    variables = NULL, #
    sim.year.num = NULL,
    sim.year.start = 2020, #
    month.start = 1, #
    realization.num = 5, #
    warm.variable = "precip", #!
    warm.signif.level = 0.90,  #
    warm.sample.num = 5000,    #
    warm.subset.criteria = list(mean = 0.1, sd = 0.2, min = 0.3,   #
       max = 0.3, sig.thr = 0.5, nsig.thr = 1.5),
    knn.sample.num = 120, #
    mc.wet.quantile = 0.3, #
    mc.extreme.quantile = 0.8, #
    dry.spell.change = rep(1, 12), #
    wet.spell.change = rep(1, 12), #
    output.path = tempdir(), #
    seed = NULL, #
    compute.parallel = FALSE, #
    num.cores = NULL
) {


  start_time <- Sys.time()

  # Directory checks
  dir.create(output.path, recursive = TRUE, showWarnings = FALSE)

  # ------------------------------------------------------------
  # Checks
  # ------------------------------------------------------------
  stopifnot(is.list(weather.data))
  stopifnot(is.data.frame(weather.grid))
  stopifnot(length(weather.date) == nrow(weather.data[[1]]))
  stopifnot(month.start %in% 1:12)
  stopifnot(is.list(weather.data), is.data.frame(weather.grid))

  stopifnot(
    "variables must be non-empty" = length(variables) > 0,
    "variables must exist in weather.data" = all(variables %in% names(weather.data[[1]])),
    "dry.spell.change must have length 12" = length(dry.spell.change) == 12,
    "wet.spell.change must have length 12" = length(wet.spell.change) == 12,
    "mc.wet.quantile must be in (0,1)" = mc.wet.quantile > 0 && mc.wet.quantile < 1,
    "mc.extreme.quantile must be in (0,1)" = mc.extreme.quantile > 0 && mc.extreme.quantile < 1,
    "mc.extreme.quantile > mc.wet.quantile" = mc.extreme.quantile > mc.wet.quantile,
    "warm.variable must be in variables" = warm.variable %in% variables,
    "weather.grid must have required columns" = all(c("id", "xind", "yind", "x", "y") %in% names(weather.grid))
  )

  # Check data consistency
  if (length(unique(sapply(weather.data, nrow))) != 1) {
    stop("All grid cells must have the same number of observations")
  }

  # Validate warm.subset.criteria
  required_criteria <- c("mean", "sd", "min", "max", "sig.thr", "nsig.thr")
  if (!all(required_criteria %in% names(warm.subset.criteria))) {
    stop("warm.subset.criteria must contain: ", paste(required_criteria, collapse = ", "))
  }

  # SET RNG seeds
  if (!is.null(seed)) set.seed(seed)
  warm_seed <- sample.int(.Machine$integer.max, 1)
  wavelet_seed <- sample.int(.Machine$integer.max, 1)
  daily_seed <- sample.int(.Machine$integer.max, 1)


  # PARALELL COMPUTING SETUP :::::::::::::::::::::::::::::::::::::::::::::::::::
  if (compute.parallel) {

    if (is.null(num.cores)) num.cores <- parallel::detectCores() - 1

      cl <- parallel::makeCluster(num.cores)
      doParallel::registerDoParallel(cl)

      # Set RNG stream for reproducibility
      if (!is.null(seed)) parallel::clusterSetRNGStream(cl, iseed = daily_seed)

      on.exit(parallel::stopCluster(cl), add = TRUE)

      logger::log_info("\n[Initialize] Starting in parallel mode:")
      logger::log_info("[Initialize] Number of cores: {num.cores}")

    } else {

      logger::log_info("\n[Initialize] Starting in sequential mode")
  }

  # Number of grids
  n_grids <- length(weather.data)

  # PREPARE DATA MATRICES ::::::::::::::::::::::::::::::::::::::::::::::::::::::
  logger::log_info("[Initialize] Randomization seed: {seed}")
  logger::log_info("[Initialize] Climate variables: {paste(variables, collapse = ', ')}")
  logger::log_info("[Initialize] Historical period: {weather.date[1]} to {weather.date[length(weather.date)]}")
  logger::log_info("[Initialize] Total number of grids: {n_grids}")

  # Leap day adjustment (only if present)
  leap_idx <- leap_day_indices(weather.date)
  if (is.null(leap_idx)) {
    his_date <- weather.date
  } else {his_date <- weather.date[-leap_idx]}

  # Date indices
  his_yr <- as.integer(format(his_date, "%Y"))
  his_wyear <- get_water_year(his_date, month.start)

  # Prepare date vector
  dates_d <- tibble(dateo = his_date, year = his_yr, wyear = his_wyear,
    month = as.integer(format(his_date, "%m")),
    day   = as.integer(format(his_date, "%d")))

  year_start <- min(his_wyear)
  year_end   <- max(his_wyear)

  dates_d <- dates_d |>
    dplyr::filter(wyear >= year_start & wyear <= year_end) |>
    dplyr::mutate(
      date = if (month.start == 1) {
        dateo
      } else {
        as.Date(sprintf("%04d-%02d-%02d", wyear, month, day))
      }
    )

  stopifnot(all(!is.na(dates_d$date)))

  # Track the index positions to be kept in the weather data
  wyear_idx <- match(dates_d$dateo, weather.date)

  # Multivariate list of daily climate data
  climate_d <- lapply(seq_len(n_grids), function(i) {
    df <- weather.data[[i]][wyear_idx, variables, drop = FALSE]
    df$wyear <- dates_d$wyear
    df
  })

  # DAILY CLIMATE DATA - Area Average
  climate_d_aavg <- weather.data[[1]][wyear_idx, variables, drop = FALSE]

  # Accumulate remaining grids (if any)
  if (n_grids > 1) {
    for (i in 2:n_grids) {
      climate_d_aavg <- climate_d_aavg + weather.data[[i]][wyear_idx, variables, drop = FALSE]
    }
    climate_d_aavg <- climate_d_aavg / n_grids
  }
  climate_d_aavg$wyear <- dates_d$wyear

  # ANNUAL CLIMATE DATA - Area Average
  climate_a_aavg <- climate_d_aavg %>%
    group_by(wyear) %>%
    summarize(across(all_of(variables), mean), .groups = "drop")

  # ------------------------------------------------------------
  # Simulated dates
  # ------------------------------------------------------------
  if (is.null(sim.year.num)) sim.year.num <- length(unique(dates_d$wyear))

  sim_year_end <- sim.year.start + sim.year.num
  sim_date_start <- as.Date(sprintf("%04d-%02d-01", sim.year.start, month.start))
  sim_date_end   <- as.Date(sprintf("%04d-%02d-01", sim_year_end, month.start)) - 1

  sim_date_ini <- seq.Date(sim_date_start, sim_date_end, by = "day")
  sim_date_ini <- sim_date_ini[format(sim_date_ini, "%m-%d") != "02-29"]

  sim_dates_d <- tibble(
    dateo = sim_date_ini,
    year  = as.integer(format(sim_date_ini, "%Y")),
    wyear = get_water_year(sim_date_ini, month.start),
    month = as.integer(format(sim_date_ini, "%m")),
    day   = as.integer(format(sim_date_ini, "%d"))
  ) |>
    dplyr::mutate(
      date = if (month.start == 1) {
        dateo
      } else {
        as.Date(sprintf("%04d-%02d-%02d", wyear, month, day))
      }
    )

  stopifnot(all(!is.na(sim_dates_d$date)))

  # ::::::::::: ANNUAL TIME-SERIES GENERATION USING WARM ::::::::::::::::::::::::

  #####  Wavelet analysis on observed annual series
  warm_variable <- climate_a_aavg %>% pull({{warm.variable}})

  # power spectra analysis of historical series
  warm_power <- weathergenr::wavelet_spectral_analysis(variable = warm_variable,
    signif.level = warm.signif.level, period.lower.limit = 2, detrend = TRUE)

  p <- weathergenr::plot_wavelet_spectra(variable = warm_variable,
            variable.year = climate_a_aavg$wyear, period = warm_power$GWS_period,
            POWER = warm_power$power , GWS = warm_power$GWS,
            GWS_signif = warm_power$GWS_signif,
            coi = warm_power$coi, sigm = warm_power$sigm)


  tryCatch({
    ggplot2::ggsave(file.path(output.path, "global_wavelet_power_spectrum.png"), p,
                    width = 10, height = 4)
  }, error = function(e) {
    logger::log_warn("Failed to save wavelet spectrum plot: {e$message}")
  })

  # if there is low-frequency signal
  if (any(!is.na(warm_power$signif_periods))) {

    logger::log_info("[WARM] Significant low-frequency components detected: {length(warm_power$COMPS)-1}")
    logger::log_info("[WARM] Detected periodiocity (years): {paste(warm_power$signif_periods, collapse = ', ')}")

    # if there is no low frequency signal (INTEGRATE THIS!!!!)
  } else {

    # Set low-frequency signal criteria to null
    logger::log_info("[WARM] No low-frequency signals detected")
    warm.subset.criteria$sig.thr <- NULL
    warm.subset.criteria$nsig.thr <- NULL

  }

  # Annual time-series simulation
  sim_annual <- wavelet_arima(
    wavelet.components = tibble(comp = warm_variable),
    sim.year.num = sim.year.num, sim.num = warm.sample.num, seed = warm_seed)

  # wavelet analysis on simulated series
  sim_power <- sapply(1:warm.sample.num, function(x) {
    wavelet_spectral_analysis(sim_annual[, x], signif.level = warm.signif.level)$GWS})


  # WAVELET POWER ANALYSIS
  # ========================================
  logger::log_info("[WARM] Computing wavelet power spectra for {warm.sample.num} simulations")

  #if (compute.parallel && warm.sample.num > 20000) {

#    logger::log_info("[WARM] Using parallel computation for wavelet analysis")

 #   parallel::clusterExport(cl,
  #                          varlist = c("sim_annual", "warm.signif.level"),
  #                          envir = environment())
  #  parallel::clusterEvalQ(cl, library(weathergenr))

   # sim_power <- foreach::foreach(
   #   x = 1:warm.sample.num,
   #   .combine = cbind,
   #   .packages = "weathergenr"
  #  ) %dopar% {
  #    wavelet_spectral_analysis(sim_annual[, x],
   #                             signif.level = warm.signif.level)$GWS
  #  }

  #} else {
  #  sim_power <- sapply(1:warm.sample.num, function(x) {
  #    wavelet_spectral_analysis(sim_annual[, x],
  #                              signif.level = warm.signif.level)$GWS
  #  })
  #}

  logger::log_info("[WARM] Subset bounds: {paste(names(warm.subset.criteria), unlist(warm.subset.criteria), sep = '=', collapse = ', ')}")

  sim_annual_sub <- filter_warm_simulations(
      series.obs = warm_variable,
      series.sim = sim_annual,
      power.obs = warm_power$GWS,
      power.sim = sim_power,
      power.period = warm_power$GWS_period,
      power.signif = warm_power$GWS_signif,
      sample.num = realization.num,
      output.path = output.path,
      bounds = warm.subset.criteria,
      seed = warm_seed,
      save.plots = TRUE,
      save.series = FALSE)

  # ::::::::::: TEMPORAL & SPATIAL DISSAGGREGATION (knn & mc) :::::::::::::::::::

  logger::log_info("[KNN] Starting daily weather simulation using KNN + Markov Chain scheme")

  if (compute.parallel) {
    `%d%` <- foreach::`%dopar%`
  } else {
    `%d%` <- foreach::`%do%`
  }

  resampled_ini <- foreach::foreach(n = seq_len(realization.num)) %d% {

    resample_weather_dates(
      PRCP_FINAL_ANNUAL_SIM = sim_annual_sub$sampled[, n],
      ANNUAL_PRCP = warm_variable,
      PRCP = climate_d_aavg$precip,
      TEMP = climate_d_aavg$temp,
      START_YEAR_SIM = sim.year.start,
      k1 = n,
      ymax = sim.year.num,
      dates.d = dates_d,
      sim.dates.d = sim_dates_d,
      knn.annual.sample.num = knn.sample.num,
      dry.spell.change = dry.spell.change,
      wet.spell.change = wet.spell.change,
      month.start = month.start,
      wet.quantile = mc.wet.quantile,
      extreme.quantile = mc.extreme.quantile,
      seed = daily_seed  + n
    )
  }

  # Prepare the results data frame
  resampled_dates <- as_tibble(matrix(0, nrow = nrow(sim_dates_d), ncol = realization.num),
        .name_repair = ~ paste0("rlz_", 1:realization.num))

  for (x in 1:ncol(resampled_dates)) {
    resampled_dates[, x] <- dates_d$dateo[match(resampled_ini[[x]], dates_d$date)]
  }

  # Write results to CSV
  tryCatch({
    utils::write.csv(sim_dates_d$date,
                     file.path(output.path, "sim_dates.csv"),
                     row.names = FALSE)
    TRUE
  }, error = function(e) {
    logger::log_error("Failed to write sim_dates.csv: {e$message}")
    FALSE
  })

  tryCatch({
    utils::write.csv(resampled_dates,
                     file.path(output.path, "resampled_dates.csv"),
                     row.names = FALSE)
    TRUE
  }, error = function(e) {
    logger::log_error("Failed to write resampled_dates.csv: {e$message}")
    FALSE
  })

  #utils::write.csv(sim_dates_d$date, file.path(output.path, "sim_dates.csv"), row.names = FALSE)
  #utils::write.csv(resampled_dates, file.path(output.path, "resampled_dates.csv"), row.names = FALSE)

  logger::log_info("[Done] Results saved to: `", output.path, "`")
  logger::log_info("[Done] Simulation complete. Elapsed time: {Sys.time() - start_time} secs")

  # Only return resampled_dates!
  return(list(resampled = resampled_dates, dates = sim_dates_d$date))
}



