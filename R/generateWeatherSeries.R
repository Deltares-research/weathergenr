#' @title Generate Synthetic Gridded Daily Weather Series
#'
#' @description
#' Generates stochastic daily weather time series for one or more grid cells by
#' combining:
#' \itemize{
#'   \item annual low-frequency variability simulated using Wavelet
#'         Autoregressive Modeling (WARM),
#'   \item annual K-nearest-neighbor (KNN) selection of historical years,
#'   \item a three-state (dry, wet, extreme) daily Markov chain for spell
#'         persistence,
#'   \item daily KNN resampling of precipitation and temperature anomalies.
#' }
#'
#' The function supports both calendar-year and water-year simulations.
#' The simulation regime is inferred automatically from \code{month.start}:
#' \itemize{
#'   \item \code{month.start == 1}: calendar-year simulation (January to December),
#'   \item \code{month.start != 1}: water-year simulation starting in the specified month.
#' }
#'
#' @details
#' The workflow consists of four main stages:
#'
#' \enumerate{
#'   \item \strong{Preprocessing of historical data:}
#'         Leap days are removed, water years are computed, and grid-cell data
#'         are aggregated to basin or domain averages for annual modeling.
#'
#'   \item \strong{Annual-scale simulation (WARM):}
#'         Low-frequency variability in the selected \code{warm.variable}
#'         (typically precipitation) is modeled using wavelet decomposition and
#'         autoregressive resampling. A subset of annual traces is retained based
#'         on user-defined summary-statistic criteria.
#'
#'   \item \strong{Daily disaggregation:}
#'         For each simulated year, historical years are selected using annual
#'         KNN matching. Daily weather is generated sequentially using a
#'         three-state Markov chain (dry, wet, extreme) and daily KNN resampling
#'         of anomalies.
#'
#'   \item \strong{Output construction:}
#'         For each realization, the function returns the sequence of resampled
#'         historical dates corresponding to the simulated daily weather.
#' }
#'
#' All simulations are performed on a 365-day calendar (no leap days).
#'
#' @param weather.data
#' A named list of data frames containing observed daily weather for each grid
#' cell. Each data frame must have one row per day (no leap days) and one column
#' per variable listed in \code{variables}.
#'
#' @param weather.grid
#' Data frame describing the spatial layout of grid cells. Must include at least
#' columns \code{id}, \code{xind}, \code{yind}, and spatial coordinates
#' \code{x}, \code{y}. Currently used for bookkeeping only.
#'
#' @param weather.date
#' Vector of class \code{Date} giving the observation dates corresponding to
#' \code{weather.data}. Must be identical for all grid cells.
#'
#' @param variables
#' Character vector giving the names of daily weather variables to simulate
#' (for example \code{c("precip", "temp")}).
#'
#' @param sim.year.start
#' Integer. First simulation year. Interpreted as a calendar year if
#' \code{month.start == 1}, otherwise as the first water year.
#'
#' @param sim.year.num
#' Integer. Number of years to simulate. If \code{NULL}, defaults to the number
#' of complete historical years available.
#'
#' @param realization.num
#' Integer. Number of independent stochastic realizations to generate.
#'
#' @param month.start
#' Integer in \code{1:12}. First month of the simulation year. Use \code{1} for
#' calendar-year simulations, or another month (for example \code{10}) for
#' water-year simulations.
#'
#' @param warm.variable
#' Character string giving the variable used for annual WARM modeling.
#' Typically a low-frequency driver such as precipitation.
#'
#' @param warm.signif.level
#' Numeric in (0, 1). Significance level used to retain low-frequency wavelet
#' components during WARM analysis.
#'
#' @param warm.sample.num
#' Integer. Number of candidate annual traces generated by the WARM model before
#' subsetting.
#'
#' @param warm.subset.criteria
#' Named list of numeric thresholds used to filter annual WARM traces based on
#' summary statistics (for example \code{mean}, \code{sd}, \code{min}, \code{max},
#' \code{sig.thr}, \code{nsig.thr}).
#'
#' @param knn.sample.num
#' Integer. Number of historical years sampled in the annual KNN step during
#' daily disaggregation.
#'
#' @param mc.wet.quantile
#' Numeric in (0, 1). Quantile used to define the wet-day threshold for the daily
#' Markov chain.
#'
#' @param mc.extreme.quantile
#' Numeric in (0, 1). Quantile used to define the extreme wet-day threshold for
#' the daily Markov chain.
#'
#' @param dry.spell.change
#' Numeric vector of length 12. Monthly adjustment factors controlling dry-spell
#' persistence in the Markov chain (\code{1} = no change).
#'
#' @param wet.spell.change
#' Numeric vector of length 12. Monthly adjustment factors controlling wet-spell
#' persistence in the Markov chain (\code{1} = no change).
#'
#' @param seed
#' Optional integer. Base random seed for reproducibility.
#'
#' @param compute.parallel
#' Logical. If \code{TRUE}, daily disaggregation across realizations is performed
#' in parallel.
#'
#' @param num.cores
#' Integer. Number of CPU cores to use for parallel execution. If \code{NULL},
#' all available cores minus one are used.
#'
#' @param output.path
#' Character string. Directory where diagnostic figures and intermediate CSV
#' files (simulated dates and resampled dates) are written.
#'
#' @return
#' A list with two elements:
#' \describe{
#'   \item{resampled}{A data frame with one column per realization, giving the
#'   resampled historical dates corresponding to each simulated day.}
#'   \item{dates}{A \code{Date} vector giving the simulated daily time axis
#'   (365-day calendar, no leap days).}
#' }
#'
#' @references
#' Steinschneider, S., Brown, C., & Lall, U. (2013).
#' Climate-informed water supply planning using wavelet-based stochastic
#' streamflow generators. \emph{Water Resources Research}.
#'
#' @export
#'
#' @import ggplot2
#' @import tidyr
#' @import patchwork
#' @import dplyr
#' @import logger
#' @importFrom dplyr mutate

generateWeatherSeries <- function(
    weather.data = NULL, #!!!
    weather.grid = NULL,
    weather.date = NULL, #!
    variables = NULL, #
    sim.year.num = NULL,
    sim.year.start = 2020, #
    month.start = 1, #
    realization.num = 5, #
    warm.variable = "precip", #!
    warm.signif.level = 0.90,  #
    warm.sample.num = 5000,    #
    warm.subset.criteria = list(mean = 0.1, sd = 0.2, min = 0.3,   #
       max = 0.3, sig.thr = 0.5, nsig.thr = 1.5),
    knn.sample.num = 120, #
    mc.wet.quantile = 0.3, #
    mc.extreme.quantile = 0.8, #
    dry.spell.change = rep(1, 12), #
    wet.spell.change = rep(1, 12), #
    output.path = tempdir(), #
    seed = NULL, #
    compute.parallel = FALSE, #
    num.cores = NULL
) {


  start_time <- Sys.time()

  # Directory checks
  dir.create(output.path, recursive = TRUE, showWarnings = FALSE)

  # ------------------------------------------------------------
  # Basic checks
  # ------------------------------------------------------------
  stopifnot(is.list(weather.data))
  stopifnot(is.data.frame(weather.grid))
  stopifnot(length(weather.date) == nrow(weather.data[[1]]))
  stopifnot(month.start %in% 1:12)
  stopifnot(is.list(weather.data), is.data.frame(weather.grid))

  # Set water-year switch
  water.year <- (month.start != 1)

  # -- Seed handling
  if (!is.null(seed)) {
    old_seed <- .Random.seed
    on.exit(
      {
        .Random.seed <<- old_seed
      },
      add = TRUE
    )
    set.seed(seed)
  }

  # Number of grids  WE WONT NEED THIS IN THE FUTURE
  ngrids <- length(weather.data)

  if (compute.parallel) {

    if (is.null(num.cores)) num.cores <- parallel::detectCores() - 1
      logger::log_info("\n[Initialize] Starting in parallel mode:")
      logger::log_info("[Initialize] Number of cores: {num.cores}")
    } else {
      logger::log_info("\n[Initialize] Starting in sequential mode")
  }

  # PREPARE DATA MATRICES ::::::::::::::::::::::::::::::::::::::::::::::::::::::
  logger::log_info("[Initialize] Randomization seed: {seed}")
  logger::log_info("[Initialize] Climate variables: {paste(variables, collapse = ', ')}")
  logger::log_info("[Initialize] Historical period: {weather.date[1]} to {weather.date[length(weather.date)]}")
  logger::log_info("[Initialize] Total number of grids: {ngrids}")

  # Leap day adjustment (only if present)
  leap_idx <- leap_day_indices(weather.date)
  if (is.null(leap_idx)) {
    his_date <- weather.date
  } else {his_date <- weather.date[-leap_idx]}

  # Date indices
  his_yr <- as.integer(format(his_date, "%Y"))
  his_wyear <- get_water_year(his_date, month.start)

  # Prepare date vector
  dates_d <- tibble(dateo = his_date, year = his_yr, wyear = his_wyear,
    month = as.integer(format(his_date, "%m")),
    day   = as.integer(format(his_date, "%d")))

  year_start <- min(his_wyear)
  year_end   <- max(his_wyear)

  dates_d <- dates_d |>
    dplyr::filter(wyear >= year_start & wyear <= year_end) |>
    dplyr::mutate(
      date = if (month.start == 1) {
        dateo
      } else {
        as.Date(sprintf("%04d-%02d-%02d", wyear, month, day))
      }
    )

  stopifnot(all(!is.na(dates_d$date)))

  # Track the index positions to be kept in the weather data
  wyear_idx <- match(dates_d$dateo, weather.date)

  # Multivariate list of daily climate data
  climate_d <- lapply(seq_len(ngrids), function(i) {
    df <- weather.data[[i]][wyear_idx, variables, drop = FALSE]
    df$wyear <- dates_d$wyear
    df
  })
  climate_d_aavg <- Reduce(`+`, climate_d) / ngrids

  # Multivariate list of annual climate data
  climate_a <- lapply(1:ngrids, function(i) {
    climate_d[[i]] %>%
      group_by(wyear) %>%
      summarize(across({{variables}}, mean), .groups = "drop")})
  climate_a_aavg <- Reduce(`+`, climate_a) / ngrids


  # ------------------------------------------------------------
  # Simulated dates (CRITICAL FIX)
  # ------------------------------------------------------------
  if (is.null(sim.year.num)) sim.year.num <- length(unique(dates_d$wyear))

  sim_year_end <- sim.year.start + sim.year.num
  sim_date_start <- as.Date(sprintf("%04d-%02d-01", sim.year.start, month.start))
  sim_date_end   <- as.Date(sprintf("%04d-%02d-01", sim_year_end, month.start)) - 1

  sim_date_ini <- seq.Date(sim_date_start, sim_date_end, by = "day")
  sim_date_ini <- sim_date_ini[format(sim_date_ini, "%m-%d") != "02-29"]

  sim_dates_d <- tibble(
    dateo = sim_date_ini,
    year  = as.integer(format(sim_date_ini, "%Y")),
    wyear = get_water_year(sim_date_ini, month.start),
    month = as.integer(format(sim_date_ini, "%m")),
    day   = as.integer(format(sim_date_ini, "%d"))
  ) |>
    dplyr::mutate(
      date = if (month.start == 1) {
        dateo
      } else {
        as.Date(sprintf("%04d-%02d-%02d", wyear, month, day))
      }
    )

  stopifnot(all(!is.na(sim_dates_d$date)))

  # ::::::::::: ANNUAL TIME-SERIES GENERATION USING WARM ::::::::::::::::::::::::

  #####  Wavelet analysis on observed annual series
  warm_variable <- climate_a_aavg %>% pull({{warm.variable}})

  # power spectra analysis of historical series
  warm_power <- weathergenr::wavelet_spectral_analysis(variable = warm_variable,
    signif.level = warm.signif.level, period.lower.limit = 2, detrend = TRUE)

  p <- weathergenr::plot_wavelet_spectra(variable = warm_variable,
            variable.year = climate_a_aavg$wyear, period = warm_power$GWS_period,
            POWER = warm_power$power , GWS = warm_power$GWS,
            GWS_signif = warm_power$GWS_signif,
            coi = warm_power$coi, sigm = warm_power$sigm)


  ggplot2::ggsave(file.path(output.path, "global_wavelet_power_spectrum.png"), p,
                  width = 10, height = 4)

  # if there is low-frequency signal
  if (any(!is.na(warm_power$signif_periods))) {

    logger::log_info("[WARM] Significant low-frequency components detected: {length(warm_power$COMPS)-1}")
    logger::log_info("[WARM] Detected periodiocity (years): {paste(warm_power$signif_periods, collapse = ', ')}")

    # if there is no low frequency signal (INTEGRATE THIS!!!!)
  } else {

    # Set low-frequency signal criteria to null
    logger::log_info("[WARM] No low-frequency signals detected")
    warm.subset.criteria$sig.thr <- NULL
    warm.subset.criteria$nsig.thr <- NULL

  }

  # Annual time-series simulation
  sim_annual <- wavelet_arima(
    wavelet.components = tibble(comp = warm_variable),
    sim.year.num = sim.year.num, sim.num = warm.sample.num, seed = seed)

  # wavelet analysis on simulated series
  sim_power <- sapply(1:warm.sample.num, function(x) {
    wavelet_spectral_analysis(sim_annual[, x], signif.level = warm.signif.level)$GWS})

  sim_annual_sub <- filter_warm_simulations(
      series.obs = warm_variable,
      series.sim = sim_annual,
      power.obs = warm_power$GWS,
      power.sim = sim_power,
      power.period = warm_power$GWS_period,
      power.signif = warm_power$GWS_signif,
      sample.num = realization.num,
      output.path = output.path,
      bounds = warm.subset.criteria,
      seed = seed,
      save.plots = TRUE,
      save.series = FALSE
    )

  logger::log_info("[WARM] Subset bounds: {paste(names(warm.subset.criteria), unlist(warm.subset.criteria), sep = '=', collapse = ', ')}")
  logger::log_info("[WARM] {ncol(sim_annual_sub$subsetted)} traces meet criteria")
  logger::log_info("[WARM] Sampling {ncol(sim_annual_sub$sampled)} traces for daily simulation")

  # ::::::::::: TEMPORAL & SPATIAL DISSAGGREGATION (knn & mc) :::::::::::::::::::

  logger::log_info("[KNN] Starting daily weather simulation using KNN + Markov Chain scheme")

  if (compute.parallel) {

    cl <- parallel::makeCluster(num.cores)
    doParallel::registerDoParallel(cl)

    if (!is.null(seed)) parallel::clusterSetRNGStream(cl, iseed = seed)

    `%d%` <- foreach::`%dopar%`
  } else {
    `%d%` <- foreach::`%do%`
  }

  resampled_ini <- foreach::foreach(n = seq_len(realization.num)) %d% {

    resample_weather_dates(
      PRCP_FINAL_ANNUAL_SIM = sim_annual_sub$sampled[, n],  #based on wy
      ANNUAL_PRCP = warm_variable, # based on wy
      PRCP = climate_d_aavg$precip, # based on wy
      TEMP = climate_d_aavg$temp, # based on wy
      START_YEAR_SIM = sim.year.start,
      k1 = n,
      ymax = sim.year.num,
      dates.d = dates_d,
      sim.dates.d = sim_dates_d,
      knn.annual.sample.num = knn.sample.num,
      dry.spell.change = dry.spell.change,
      wet.spell.change = wet.spell.change,
      #YEAR_D = dates_d$wyear, #his_yr,
      month.start = month.start,
      wet.quantile = mc.wet.quantile,
      extreme.quantile = mc.extreme.quantile,
      seed = seed + n
    )
  }

  if (compute.parallel) parallel::stopCluster(cl)


  # Prepare the results data frame
  resampled_dates <- as_tibble(matrix(0, nrow = nrow(sim_dates_d), ncol = realization.num),
        .name_repair = ~ paste0("rlz_", 1:realization.num))

  for (x in 1:ncol(resampled_dates)) {
    resampled_dates[, x] <- dates_d$dateo[match(resampled_ini[[x]], dates_d$date)]
  }

  #sum(as.numeric(resampled_ini[[1]] - resampled_dates$rlz_1))

  # Take this outside of the function!!!!
  utils::write.csv(sim_dates_d$date, file.path(output.path, "sim_dates.csv"), row.names = FALSE)
  utils::write.csv(resampled_dates, file.path(output.path, "resampled_dates.csv"), row.names = FALSE)

  logger::log_info("[Output] Results saved to: `", output.path, "`")
  logger::log_info("[Done] Simulation complete. Elapsed time: {Sys.time() - start_time} secs")

  # Only return resampled_dates!
  return(list(resampled = resampled_dates, dates = sim_dates_d$date))
}



