#' Resample Daily Weather Dates Using Annual KNN and Markov Chain Logic
#'
#' @description
#' Resamples daily precipitation and temperature sequences by combining:
#' \itemize{
#'   \item annual K-nearest-neighbor (KNN) selection of observed years,
#'   \item a three-state Markov chain for wet and dry spell persistence,
#'   \item daily KNN resampling on precipitation and temperature anomalies.
#' }
#'
#' The function supports both calendar-year and water-year simulations.
#' The regime is inferred automatically from `year_start_month`:
#' if `year_start_month == 1`, calendar-year logic is used; otherwise, water-year
#' logic is assumed.
#'
#' @param annual_prcp_sim Numeric vector of length `n_sim_years`. Synthetic
#'   annual precipitation totals generated by the annual model (e.g., WARM),
#'   indexed by simulated year.
#' @param annual_prcp_obs Numeric vector. Observed annual precipitation totals
#'   corresponding to historical water years.
#' @param daily_prcp_obs Numeric vector. Observed daily precipitation values
#'   (no leap days), aligned with `obs_dates_table`.
#' @param daily_temp_obs Numeric vector. Observed daily temperature values
#'   (no leap days), aligned with `obs_dates_table`.
#' @param sim_start_year Integer. First simulation year (calendar year if
#'   `year_start_month == 1`, otherwise first water year).
#' @param realization_id Integer. Realization index, used to perturb the random
#'   seed so that multiple realizations are independent.
#' @param n_sim_years Integer. Number of simulated years.
#' @param obs_dates_table Data frame containing observed date information. Must
#'   include columns `date`, `month`, `day`, and `wyear`.
#' @param sim_dates_table Data frame containing simulated date information
#'   (no leap days). Must include columns `month`, `day`, and `wyear`.
#' @param year_start_month Integer in 1:12. First month of the simulation year.
#'   Use 1 for calendar-year simulations, or another month for water-year
#'   simulations.
#' @param annual_knn_n Integer. Number of historical years sampled in the
#'   annual KNN step.
#' @param wet_q Numeric between 0 and 1. Quantile used to define the wet
#'   threshold for daily precipitation states.
#' @param extreme_q Numeric between 0 and 1. Quantile used to define the very
#'   wet (extreme) precipitation threshold.
#' @param dry_spell_factor Numeric vector of length 12. Monthly adjustment
#'   factors controlling dry spell persistence in the Markov chain.
#' @param wet_spell_factor Numeric vector of length 12. Monthly adjustment
#'   factors controlling wet spell persistence in the Markov chain.
#' @param seed Optional integer. Base random seed for reproducibility.
#'
#' @details
#' For each simulated year, a subset of observed water years is selected
#' using annual KNN matching against `annual_prcp_sim`. Daily weather is then
#' generated sequentially:
#'
#' \enumerate{
#'   \item The first day of each simulated year is sampled from observed
#'         days matching the simulated month and day.
#'   \item Subsequent days are generated using a Markov chain to simulate
#'         wet and dry states.
#'   \item Conditional on the simulated state, candidate observed days are
#'         selected using calendar constraints and expanded search windows.
#'   \item A daily KNN step on precipitation and temperature anomalies is
#'         used to select the next-day weather values.
#' }
#'
#' In calendar-year mode (`year_start_month == 1`), transitions that cross
#' December to January are explicitly excluded to avoid cross-year
#' contamination.
#'
#' @return
#' A `Date` vector of length equal to `nrow(sim_dates_table)`, giving the
#' resampled observed dates corresponding to each simulated day.
#'
#' @importFrom stats runif
#' @export
resample_weather_dates <- function(
    annual_prcp_sim,
    annual_prcp_obs,
    daily_prcp_obs,
    daily_temp_obs,
    sim_start_year,
    realization_id,
    n_sim_years,
    obs_dates_table,
    sim_dates_table,
    year_start_month = 1,
    annual_knn_n = 50,
    wet_q = 0.2,
    extreme_q = 0.8,
    dry_spell_factor = rep(1, 12),
    wet_spell_factor = rep(1, 12),
    seed = NULL
) {

  # Checks and controls
  if (!is.numeric(year_start_month) || length(year_start_month) != 1L ||
      is.na(year_start_month) || !year_start_month %in% 1:12) {
    stop("year_start_month must be a single integer between 1 and 12", call. = FALSE)
  }

  # SET RNG
  base_seed <- if (is.null(seed)) NULL else seed + realization_id

  if (!is.null(base_seed)) {
    if (exists(".Random.seed", envir = .GlobalEnv)) {
      old_seed <- .Random.seed
      has_seed <- TRUE
    } else {
      has_seed <- FALSE
    }
    on.exit({ if (has_seed) .Random.seed <<- old_seed }, add = TRUE)
    set.seed(base_seed)
  }

  # SET Date logic and parameters
  is_water_year <- (year_start_month != 1L)
  year_month_order <- if (year_start_month == 1L) 1:12 else c(year_start_month:12, 1:(year_start_month - 1L))

  month_to_year_index <- integer(12)
  month_to_year_index[year_month_order] <- seq_along(year_month_order)

  dates_obs  <- obs_dates_table$date
  months_obs <- obs_dates_table$month
  days_obs   <- obs_dates_table$day
  wyears_obs <- obs_dates_table$wyear
  water_years_obs <- sort(unique(obs_dates_table$wyear))

  sim_length <- nrow(sim_dates_table)
  months_sim <- sim_dates_table$month
  days_sim   <- sim_dates_table$day
  wyears_sim <- sim_dates_table$wyear

  sim_prcp <- numeric(sim_length)
  sim_temp <- numeric(sim_length)
  sim_occ  <- integer(sim_length)
  sim_date <- as.Date(rep(NA, sim_length))
  sim_obs_idx <- integer(sim_length)

  # Weights used in daily KNN sampling
  knnw_prcp <- 100
  knnw_temp <- 10

  # Constants
  offsets7  <- -3:3
  offsets61 <- -30:30

  rn_all <- runif(sim_length)
  k_annual <- ceiling(sqrt(length(annual_prcp_obs)))

  # Expand the date window with a given offset value
  expand_indices <- function(idx, offsets, max_len) {
    out <- idx[rep(seq_along(idx), each = length(offsets))] +
      rep(offsets, times = length(idx))
    out[out > 0 & (out + 1L) <= max_len]
  }

  for (y in seq_len(n_sim_years)) {

    year_start_idx <- (y - 1L) * 365L + 1L
    if (year_start_idx > sim_length) break

    # Annual KNN: select observed years
    year_sample_idx <- knn_sample(
      candidates = annual_prcp_obs,
      target = annual_prcp_sim[y],
      k = k_annual,
      n = annual_knn_n,
      prob = TRUE,
      seed = if (is.null(base_seed)) NULL else base_seed + y
    )

    cur_years <- water_years_obs[year_sample_idx]

    idx_by_year <- split(seq_along(wyears_obs), wyears_obs)
    obs_idx <- unlist(idx_by_year[as.character(cur_years)], use.names = FALSE)
    obs_idx <- obs_idx[!is.na(obs_idx)]

    prcp_y  <- daily_prcp_obs[obs_idx]
    temp_y  <- daily_temp_obs[obs_idx]
    date_y  <- dates_obs[obs_idx]
    month_y <- months_obs[obs_idx]
    day_y   <- days_obs[obs_idx]
    wyear_y <- wyears_obs[obs_idx]

    # Month-day lookup (subset-specific)
    monthday_key_y <- paste(month_y, day_y, sep = ".")
    lookup_day_idx_y <- split(seq_along(monthday_key_y), monthday_key_y)

    # Monthly means
    mean_mon_prcp <- tapply(prcp_y, month_y, mean)
    mean_mon_temp <- tapply(temp_y, month_y, mean)
    mean_mon_prcp[is.na(mean_mon_prcp)] <- mean(prcp_y)
    mean_mon_temp[is.na(mean_mon_temp)] <- mean(temp_y)

    # Monthly standard deviations
    sd_mon_prcp <- tapply(prcp_y, month_y, sd)
    sd_mon_temp <- tapply(temp_y, month_y, sd)

    # Force full 12-month coverage
    sd_mon_prcp <- sd_mon_prcp[as.character(1:12)]
    sd_mon_temp <- sd_mon_temp[as.character(1:12)]

    # Global fallback
    sd_mon_prcp[is.na(sd_mon_prcp)] <- sd(prcp_y)
    sd_mon_temp[is.na(sd_mon_temp)] <- sd(temp_y)

    # Apply SD floor (numerical consistency)
    sd_floor_prcp <- 0.1
    sd_floor_temp <- 0.1
    sd_mon_prcp <- pmax(sd_mon_prcp, sd_floor_prcp)
    sd_mon_temp <- pmax(sd_mon_temp, sd_floor_temp)

    knn_weights_by_month <- lapply(seq_along(year_month_order), function(i) {
      c(knnw_prcp / sd_mon_prcp[year_month_order[i]],
        knnw_temp / sd_mon_temp[year_month_order[i]])
    })

    # Thresholds aligned to year_month_order
    wet_thresh <- sapply(year_month_order, function(m) {
      vals <- prcp_y[month_y == m]
      if (!length(vals)) NA_real_ else quantile(vals, wet_q, names = FALSE)
    })

    extreme_thresh <- sapply(year_month_order, function(m) {
      vals <- prcp_y[month_y == m & prcp_y > 0]
      if (!length(vals)) NA_real_ else quantile(vals, extreme_q, names = FALSE)
    })

    wet_thresh[is.na(wet_thresh)] <- quantile(prcp_y, wet_q)
    extreme_thresh[is.na(extreme_thresh)] <- quantile(prcp_y[prcp_y > 0], extreme_q)

    # Markov probabilities
    probs <- monthly_markov_probs(
      precip.lag0 = prcp_y[-1],
      precip.lag1 = prcp_y[-length(prcp_y)],
      month.lag0  = month_y[-1],
      month.lag1  = month_y[-length(prcp_y)],
      year.lag0   = wyear_y[-1],
      year.lag1   = wyear_y[-length(wyear_y)],
      year.idx = y,
      wet.threshold = wet_thresh,
      extreme.threshold = extreme_thresh,
      month.list = year_month_order,
      sim.months = months_sim,
      sim.water.years = wyears_sim,
      sim.start.year = sim_start_year,
      sim.length = sim_length,
      dry.spell.change = dry_spell_factor,
      wet.spell.change = wet_spell_factor,
      alpha = 1.0
    )

    # FIRST DAY OF THIS SIM YEAR
    first_month <- months_sim[year_start_idx]
    first_month_idx <- match(first_month, year_month_order)
    first_day <- days_sim[year_start_idx]

    key0 <- paste(first_month, first_day, sep = ".")
    cand0 <- lookup_day_idx_y[[key0]]

    # Fallback options
    if (!length(cand0)) cand0 <- which(month_y == first_month)
    if (!length(cand0)) cand0 <- seq_along(prcp_y)

    # Calendar-year safeguard: forbid observed Dec->Jan cross-year transitions
    if (!is_water_year && y > 1L) {
      prev_obs_year <- wyear_y[sim_obs_idx[year_start_idx - 1L]]
      cand0 <- cand0[wyear_y[cand0] == prev_obs_year]
      if (!length(cand0)) cand0 <- which(wyear_y == prev_obs_year & month_y == first_month)
    }

    i0 <- sample(cand0, 1L)
    sim_prcp[year_start_idx] <- prcp_y[i0]
    sim_temp[year_start_idx] <- temp_y[i0]
    sim_date[year_start_idx] <- date_y[i0]
    sim_obs_idx[year_start_idx] <- i0

    # Set first day's markov state
    if (sim_prcp[year_start_idx] <= wet_thresh[first_month_idx]) {
      sim_occ[year_start_idx] <- 0L
    } else if (sim_prcp[year_start_idx] <= extreme_thresh[first_month_idx]) {
      sim_occ[year_start_idx] <- 1L
    } else {
      sim_occ[year_start_idx] <- 2L
    }

    # DAILY LOOP: remaining 364 days of this year
    sim_idx <- year_start_idx

    for (j in 2:365) {

      sim_idx <- sim_idx + 1L
      if (sim_idx > sim_length) break

      prev_idx <- sim_idx - 1L

      sim_occ[sim_idx] <- markov_next_state(
        sim_occ[prev_idx],
        rn_all[prev_idx],
        prev_idx,
        probs$p00_final,
        probs$p01_final,
        probs$p10_final,
        probs$p11_final,
        probs$p20_final,
        probs$p21_final
      )

      cur_month <- months_sim[sim_idx]
      cur_day   <- days_sim[sim_idx]
      m_idx <- month_to_year_index[cur_month]
      if (is.na(m_idx)) m_idx <- 1L

      key <- paste(cur_month, cur_day, sep = ".")
      obs_candidates <- lookup_day_idx_y[[key]]
      if (!length(obs_candidates)) obs_candidates <- which(month_y == cur_month)

      if (!length(obs_candidates)) {
        sim_prcp[sim_idx] <- sim_prcp[prev_idx]
        sim_temp[sim_idx] <- sim_temp[prev_idx]
        sim_date[sim_idx] <- sim_date[prev_idx]
        next
      }

      obs_idx_window <- expand_indices(obs_candidates, offsets7, length(prcp_y))

      if (!length(obs_idx_window)) {
        i <- sample(obs_candidates, 1L)
        sim_prcp[sim_idx] <- prcp_y[i]
        sim_temp[sim_idx] <- temp_y[i]
        sim_date[sim_idx] <- date_y[i]
        sim_obs_idx[sim_idx] <- i
        next
      }

      state_idx <- get_state_indices(
        from.state = sim_occ[prev_idx],
        to.state = sim_occ[sim_idx],
        prcp = prcp_y,
        candidate.idx = obs_idx_window,
        wet.thr = wet_thresh[m_idx],
        extreme.thr = extreme_thresh[m_idx]
      )

      if (!length(state_idx)) {
        obs_idx_window <- expand_indices(obs_candidates, offsets61, length(prcp_y))
        state_idx <- get_state_indices(
          from.state = sim_occ[prev_idx],
          to.state = sim_occ[sim_idx],
          prcp = prcp_y,
          candidate.idx = obs_idx_window,
          wet.thr = wet_thresh[m_idx],
          extreme.thr = extreme_thresh[m_idx]
        )
      }

      if (!length(state_idx)) {
        fb <- which(month_y == cur_month & (seq_along(prcp_y) + 1L) <= length(prcp_y))
        if (!is_water_year) fb <- fb[wyear_y[fb] == wyear_y[fb + 1L]]
        if (!length(fb)) {
          fb <- which((seq_along(prcp_y) + 1L) <= length(prcp_y))
          if (!is_water_year) fb <- fb[wyear_y[fb] == wyear_y[fb + 1L]]
        }

        i <- sample(fb, 1L)
        sim_prcp[sim_idx] <- prcp_y[i]
        sim_temp[sim_idx] <- temp_y[i]
        sim_date[sim_idx] <- date_y[i]
        sim_obs_idx[sim_idx] <- i
        next
      }

      possible_days <- obs_idx_window[state_idx]

      if (!is_water_year) {
        possible_days <- possible_days[wyear_y[possible_days] == wyear_y[possible_days + 1L]]
      }

      if (!length(possible_days)) {
        fb <- which(month_y == cur_month & (seq_along(prcp_y) + 1L) <= length(prcp_y))
        if (!is_water_year) fb <- fb[wyear_y[fb] == wyear_y[fb + 1L]]
        if (!length(fb)) {
          fb <- which((seq_along(prcp_y) + 1L) <= length(prcp_y))
          if (!is_water_year) fb <- fb[wyear_y[fb] == wyear_y[fb + 1L]]
        }

        i <- sample(fb, 1L)
        sim_prcp[sim_idx] <- prcp_y[i]
        sim_temp[sim_idx] <- temp_y[i]
        sim_date[sim_idx] <- date_y[i]
        sim_obs_idx[sim_idx] <- i
        next
      }

      next_days <- possible_days + 1L
      prcp_tomorrow <- prcp_y[next_days]
      temp_tomorrow <- temp_y[next_days]
      date_tomorrow <- date_y[next_days]

      cur_sim_prcp_anom <- sim_prcp[prev_idx] - mean_mon_prcp[cur_month]
      cur_sim_temp_anom <- sim_temp[prev_idx] - mean_mon_temp[cur_month]

      prcp_today_anom <- prcp_y[possible_days] - mean_mon_prcp[cur_month]
      temp_today_anom <- temp_y[possible_days] - mean_mon_temp[cur_month]

      k_day <- max(1L, round(sqrt(length(possible_days))))
      k_day <- min(k_day, length(possible_days))

      res <- knn_sample(
        candidates = cbind(prcp_today_anom, temp_today_anom),
        target = c(cur_sim_prcp_anom, cur_sim_temp_anom),
        k = k_day,
        n = 1,
        prob = TRUE,
        weights = knn_weights_by_month[[m_idx]],
        seed = if (is.null(base_seed)) NULL else base_seed + sim_idx
      )

      idx <- get_result_index(result = res, precip.tomorrow = prcp_tomorrow)

      # Enforce calendar-year constraint AFTER KNN
      if (!is_water_year) {
        prev_obs_year <- wyear_y[sim_obs_idx[prev_idx]]
        valid <- which(wyear_y[next_days] == prev_obs_year)
        if (length(valid)) idx <- idx[idx %in% valid]
        if (!length(idx)) idx <- sample(valid, 1L)
      }

      if (is.na(idx) || idx < 1L || idx > length(prcp_tomorrow)) {
        idx <- sample(seq_along(prcp_tomorrow), 1L)
      }

      sim_prcp[sim_idx] <- prcp_tomorrow[idx]
      sim_temp[sim_idx] <- temp_tomorrow[idx]
      sim_date[sim_idx] <- date_tomorrow[idx]
      sim_obs_idx[sim_idx] <- next_days[idx]
    }
  }

  class(sim_date) <- "Date"
  sim_date
}
