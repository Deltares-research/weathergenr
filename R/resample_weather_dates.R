#' Resample Daily Weather Dates Using Annual KNN and Markov Chain Logic
#'
#' @description
#' Resamples daily precipitation and temperature sequences by combining:
#' \itemize{
#'   \item annual K-nearest-neighbor (KNN) selection of observed years,
#'   \item a three-state Markov chain for wet and dry spell persistence,
#'   \item daily KNN resampling on precipitation and temperature anomalies.
#' }
#'
#' The function supports both calendar-year and water-year simulations.
#' The regime is inferred automatically from `month.start`:
#' if `month.start == 1`, calendar-year logic is used; otherwise, water-year
#' logic is assumed.
#'
#' @param PRCP_FINAL_ANNUAL_SIM Numeric vector of length `ymax`. Synthetic
#'   annual precipitation totals generated by the annual model (for example
#'   WARM), indexed by simulated year.
#' @param ANNUAL_PRCP Numeric vector. Observed annual precipitation totals
#'   corresponding to historical water years.
#' @param PRCP Numeric vector. Observed daily precipitation values (no leap
#'   days), aligned with `dates.d`.
#' @param TEMP Numeric vector. Observed daily temperature values (no leap
#'   days), aligned with `dates.d`.
#' @param START_YEAR_SIM Integer. First simulation year (calendar year if
#'   `month.start == 1`, otherwise first water year).
#' @param k1 Integer. Realization index, used to perturb the random seed so
#'   that multiple realizations are independent.
#' @param ymax Integer. Number of simulated years.
#' @param dates.d Data frame containing observed date information. Must
#'   include columns `date`, `month`, `day`, and `wyear`.
#' @param sim.dates.d Data frame containing simulated date information
#'   (no leap days). Must include columns `month`, `day`, and `wyear`.
#' @param month.start Integer in 1:12. First month of the simulation year.
#'   Use 1 for calendar-year simulations, or another month for water-year
#'   simulations.
#' @param knn.annual.sample.num Integer. Number of historical years sampled
#'   in the annual KNN step.
#' @param wet.quantile Numeric between 0 and 1. Quantile used to define the
#'   wet threshold for daily precipitation states.
#' @param extreme.quantile Numeric between 0 and 1. Quantile used to define
#'   the very wet (extreme) precipitation threshold.
#' @param dry.spell.change Numeric vector of length 12. Monthly adjustment
#'   factors controlling dry spell persistence in the Markov chain.
#' @param wet.spell.change Numeric vector of length 12. Monthly adjustment
#'   factors controlling wet spell persistence in the Markov chain.
#' @param seed Optional integer. Base random seed for reproducibility.
#' @param alpha Numeric. Base smoothing strength for monthly Markov transition
#'   probabilities. Actual smoothing is applied automatically as
#'   alpha / sqrt(N_m), where N_m is the number of observed transitions
#'   in each month.
#' @details
#' For each simulated year, a subset of observed water years is selected
#' using annual KNN matching against `PRCP_FINAL_ANNUAL_SIM`. Daily weather
#' is then generated sequentially:
#'
#' \enumerate{
#'   \item The first day of each simulated year is sampled from observed
#'         days matching the simulated month and day.
#'   \item Subsequent days are generated using a Markov chain to simulate
#'         wet and dry states.
#'   \item Conditional on the simulated state, candidate observed days are
#'         selected using calendar constraints and expanded search windows.
#'   \item A daily KNN step on precipitation and temperature anomalies is
#'         used to select the next-day weather values.
#' }
#'
#' In calendar-year mode (`month.start == 1`), transitions that cross
#' December to January are explicitly excluded to avoid cross-year
#' contamination.
#'
#' @return
#' A `Date` vector of length equal to `nrow(sim.dates.d)`, giving the
#' resampled observed dates corresponding to each simulated day.
#'
#' @export
resample_weather_dates <- function(
    PRCP_FINAL_ANNUAL_SIM,
    ANNUAL_PRCP,
    PRCP,
    TEMP,
    START_YEAR_SIM,
    k1,
    ymax,
    dates.d,
    sim.dates.d,
    month.start = 1,
    knn.annual.sample.num = 50,
    wet.quantile = 0.2,
    extreme.quantile = 0.8,
    dry.spell.change = rep(1, 12),
    wet.spell.change = rep(1, 12),
    alpha = 1.0,
    seed = NULL
) {

  if (!month.start %in% 1:12)
    stop("month.start must be in 1:12")

  water.year <- (month.start != 1)

  if (!is.null(seed)) {
    old_seed <- .Random.seed
    on.exit({ .Random.seed <<- old_seed }, add = TRUE)
    set.seed(seed + k1)
  }

  ## -------------------------------------------------
  ## Observed date components
  ## -------------------------------------------------
  dates_obs  <- dates.d$date
  months_obs <- dates.d$month
  days_obs   <- dates.d$day
  wyears_obs <- dates.d$wyear

  ## Simulation calendar
  sim_length <- nrow(sim.dates.d)
  months_sim <- sim.dates.d$month
  days_sim   <- sim.dates.d$day
  wyears_sim <- sim.dates.d$wyear

  ## Output
  sim_date <- as.Date(rep(NA, sim_length))
  sim_occ  <- integer(sim_length)

  ## Random numbers for Markov transitions
  rn_all <- runif(sim_length)

  ## Month ordering
  month_list <- if (month.start == 1)
    1:12 else c(month.start:12, 1:(month.start - 1))

  ## Water-year anchors
  water_years_obs <- wyears_obs[months_obs == month.start & days_obs == 1]
  ## Pre-split observed indices by year (once)
  idx_by_year <- split(seq_along(wyears_obs), wyears_obs)
  ## Annual KNN size
  k_annual <- ceiling(sqrt(length(ANNUAL_PRCP)))

  ## -------------------------------------------------
  ## YEAR LOOP
  ## -------------------------------------------------
  for (y in seq_len(ymax)) {

    year_start_idx <- (y - 1L) * 365L + 1L
    if (year_start_idx > sim_length) break

    ## ---- Annual KNN year selection ----
    year_sample_idx <- knn_sample(
      candidates = ANNUAL_PRCP,
      target = PRCP_FINAL_ANNUAL_SIM[y],
      k = k_annual,
      n = knn.annual.sample.num,
      prob = TRUE,
      seed = seed + k1 * y)

    cur_years <- water_years_obs[year_sample_idx]
    obs_idx <- unlist(idx_by_year[as.character(cur_years)], use.names = FALSE)
    obs_idx <- obs_idx[!is.na(obs_idx)]

    prcp_y  <- PRCP[obs_idx]
    temp_y  <- TEMP[obs_idx]
    date_y  <- dates_obs[obs_idx]
    month_y <- months_obs[obs_idx]
    day_y   <- days_obs[obs_idx]
    wyear_y <- wyears_obs[obs_idx]

    ## ---- Month-day lookup using integer keys ----
    key_y <- month_y * 32L + day_y
    lookup_day_idx_y <- split(seq_along(key_y), key_y)
    idx_by_month_y   <- split(seq_along(month_y), month_y)

    ## ---- monthly thresholds ----
    wet_thresh     <- numeric(length(month_list))
    extreme_thresh <- numeric(length(month_list))

    for (i in seq_along(month_list)) {

      m <- month_list[i]
      v <- prcp_y[month_y == m]

      wet_thresh[i] <-
        if (length(v)) quantile(v, wet.quantile)
      else quantile(prcp_y, wet.quantile)

      vp <- v[v > 0]
      extreme_thresh[i] <-
        if (length(vp)) quantile(vp, extreme.quantile)
      else quantile(prcp_y[prcp_y > 0], extreme.quantile)

    }

    # compute occurrence state ONCE
    m_idx <- match(month_y, month_list)
    if (anyNA(m_idx))
      stop("Month mismatch in state computation")

    state_y <- integer(length(prcp_y))
    state_y[prcp_y <= wet_thresh[m_idx]] <- 0L
    state_y[prcp_y > wet_thresh[m_idx] & prcp_y <= extreme_thresh[m_idx]] <- 1L
    state_y[prcp_y > extreme_thresh[m_idx]] <- 2L

    state_lag1 <- state_y[-length(state_y)]
    state_lag0 <- state_y[-1]

    ## ---- Markov probabilities ----
    probs <- monthly_markov_probs(
      PRCP_LAG0 = prcp_y[-1],
      PRCP_LAG1 = prcp_y[-length(prcp_y)],
      MONTH_LAG0 = month_y[-1],
      MONTH_LAG1 = month_y[-length(prcp_y)],
      YEAR_LAG0  = wyear_y[-1],
      YEAR_LAG1  = wyear_y[-length(wyear_y)],
      wet_threshold = wet_thresh,
      extreme_threshold = extreme_thresh,
      month_list = month_list,
      MONTH_SIM = months_sim,
      WATER_YEAR_SIM = wyears_sim,
      y = y,
      START_YEAR_SIM = START_YEAR_SIM,
      dry.spell.change = dry.spell.change,
      wet.spell.change = wet.spell.change,
      SIM_LENGTH = sim_length,
      alpha = alpha)

    off7  <- -3:3
    off61 <- -30:30
    sim_idx <- year_start_idx

    ## -------------------------------------------------
    ## FIRST DAY
    ## -------------------------------------------------

    key0 <- months_sim[year_start_idx] * 32L + days_sim[year_start_idx]
    cand0 <- lookup_day_idx_y[[as.character(key0)]]
    if (!length(cand0))
      cand0 <- idx_by_month_y[[as.character(months_sim[year_start_idx])]]
    if (!length(cand0))
      cand0 <- seq_along(prcp_y)

    i0 <- sample(cand0, 1)
    prev_prcp <- prcp_y[i0]
    prev_temp <- temp_y[i0]
    prev_occ  <- state_y[i0]

    sim_occ[year_start_idx]  <- prev_occ
    sim_date[year_start_idx] <- date_y[i0]

    ## -------------------------------------------------
    ## DAILY LOOP
    ## -------------------------------------------------
    for (j in 2:365) {

      sim_idx <- sim_idx + 1L
      if (sim_idx > sim_length) break
      prev_idx <- sim_idx - 1L

      next_occ <- markov_next_state(
        prev_state = prev_occ,
        rn = rn_all[prev_idx],
        idx = prev_idx,
        p00 = probs$p00_final,
        p01 = probs$p01_final,
        p10 = probs$p10_final,
        p11 = probs$p11_final,
        p20 = probs$p20_final,
        p21 = probs$p21_final)

      sim_occ[sim_idx] <- next_occ


      key <- months_sim[sim_idx] * 32L + days_sim[sim_idx]
      obs_candidates <- lookup_day_idx_y[[as.character(key)]]
      if (!length(obs_candidates))
        obs_candidates <- idx_by_month_y[[as.character(months_sim[sim_idx])]]

      if (!length(obs_candidates)) {
        sim_date[sim_idx] <- sim_date[prev_idx]
        prev_occ <- next_occ
        next
      }

      # cur_month <- months_sim[sim_idx]
      # cur_day   <- days_sim[sim_idx]
      # m_idx <- match(cur_month, month_list)
      # if (is.na(m_idx)) m_idx <- 1L
      #
      # key <- cur_month * 32L + cur_day
      # obs_candidates <- lookup_day_idx_y[[as.character(key)]]
      # if (!length(obs_candidates)) obs_candidates <- idx_by_month_y[[as.character(cur_month)]]
      #
      # if (!length(obs_candidates)) {
      #   sim_date[sim_idx] <- sim_date[prev_idx]
      #   next
      # }

      obs_idx_window <- unique(rep(obs_candidates, each = length(off7)) + off7)
      obs_idx_window <- obs_idx_window[obs_idx_window > 0 & (obs_idx_window + 1) <= length(prcp_y)]

      if (!length(obs_idx_window)) {
        i <- sample(obs_candidates, 1)
        prev_prcp <- prcp_y[i]
        prev_temp <- temp_y[i]
        prev_occ  <- next_occ
        sim_date[sim_idx] <- date_y[i]
        next
      }

      state_idx <- which(state_y[obs_idx_window] == sim_occ[prev_idx] &
                         state_y[obs_idx_window + 1] == sim_occ[sim_idx])

      if (!length(state_idx)) {
        obs_idx_window <- unique(rep(obs_candidates, each = length(off61)) + off61)
        obs_idx_window <- obs_idx_window[obs_idx_window > 0 & (obs_idx_window + 1) <= length(prcp_y)]
        state_idx <- which(state_y[obs_idx_window]  == sim_occ[prev_idx] &
                           state_y[obs_idx_window + 1] == sim_occ[sim_idx])
      }

      if (!length(state_idx)) {
        i <- sample(obs_candidates, 1)
        prev_prcp <- prcp_y[i]
        prev_temp <- temp_y[i]
        prev_occ  <- next_occ
        sim_date[sim_idx] <- date_y[i]
        next
      }

      possible_days <- obs_idx_window[state_idx]

      if (!water.year) {
        ok <- wyear_y[possible_days] == wyear_y[possible_days + 1]
        possible_days <- possible_days[ok]
      }

      if (!length(possible_days)) {
        i <- sample(obs_candidates, 1)
        prev_prcp <- prcp_y[i]
        prev_temp <- temp_y[i]
        prev_occ  <- next_occ
        sim_date[sim_idx] <- date_y[i]
        next
      }

      next_days <- possible_days + 1L
      sim_date[sim_idx] <- date_y[next_days[sample.int(length(next_days), 1)]]
      prev_occ <- next_occ
    }
  }

  class(sim_date) <- "Date"
  sim_date
}
