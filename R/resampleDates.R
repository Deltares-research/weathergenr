#' Resample Daily Weather Dates Using Annual KNN and Markov Chain Logic
#'
#' @description
#' Resamples daily precipitation and temperature sequences by combining:
#' \itemize{
#'   \item annual K-nearest-neighbor (KNN) selection of observed years,
#'   \item a three-state Markov chain for wet and dry spell persistence,
#'   \item daily KNN resampling on precipitation and temperature anomalies.
#' }
#'
#' The function supports both calendar-year and water-year simulations.
#' The regime is inferred automatically from `month.start`:
#' if `month.start == 1`, calendar-year logic is used; otherwise, water-year
#' logic is assumed.
#'
#' @param PRCP_FINAL_ANNUAL_SIM Numeric vector of length `ymax`. Synthetic
#'   annual precipitation totals generated by the annual model (for example
#'   WARM), indexed by simulated year.
#' @param ANNUAL_PRCP Numeric vector. Observed annual precipitation totals
#'   corresponding to historical water years.
#' @param PRCP Numeric vector. Observed daily precipitation values (no leap
#'   days), aligned with `dates.d`.
#' @param TEMP Numeric vector. Observed daily temperature values (no leap
#'   days), aligned with `dates.d`.
#' @param START_YEAR_SIM Integer. First simulation year (calendar year if
#'   `month.start == 1`, otherwise first water year).
#' @param k1 Integer. Realization index, used to perturb the random seed so
#'   that multiple realizations are independent.
#' @param ymax Integer. Number of simulated years.
#' @param dates.d Data frame containing observed date information. Must
#'   include columns `date`, `month`, `day`, and `wyear`.
#' @param sim.dates.d Data frame containing simulated date information
#'   (no leap days). Must include columns `month`, `day`, and `wyear`.
#' @param month.start Integer in 1:12. First month of the simulation year.
#'   Use 1 for calendar-year simulations, or another month for water-year
#'   simulations.
#' @param knn.annual.sample.num Integer. Number of historical years sampled
#'   in the annual KNN step.
#' @param wet.quantile Numeric between 0 and 1. Quantile used to define the
#'   wet threshold for daily precipitation states.
#' @param extreme.quantile Numeric between 0 and 1. Quantile used to define
#'   the very wet (extreme) precipitation threshold.
#' @param dry.spell.change Numeric vector of length 12. Monthly adjustment
#'   factors controlling dry spell persistence in the Markov chain.
#' @param wet.spell.change Numeric vector of length 12. Monthly adjustment
#'   factors controlling wet spell persistence in the Markov chain.
#' @param seed Optional integer. Base random seed for reproducibility.
#'
#' @details
#' For each simulated year, a subset of observed water years is selected
#' using annual KNN matching against `PRCP_FINAL_ANNUAL_SIM`. Daily weather
#' is then generated sequentially:
#'
#' \enumerate{
#'   \item The first day of each simulated year is sampled from observed
#'         days matching the simulated month and day.
#'   \item Subsequent days are generated using a Markov chain to simulate
#'         wet and dry states.
#'   \item Conditional on the simulated state, candidate observed days are
#'         selected using calendar constraints and expanded search windows.
#'   \item A daily KNN step on precipitation and temperature anomalies is
#'         used to select the next-day weather values.
#' }
#'
#' In calendar-year mode (`month.start == 1`), transitions that cross
#' December to January are explicitly excluded to avoid cross-year
#' contamination.
#'
#' @return
#' A `Date` vector of length equal to `nrow(sim.dates.d)`, giving the
#' resampled observed dates corresponding to each simulated day.
#'
#' @export
resampleDates <- function(
    PRCP_FINAL_ANNUAL_SIM,
    ANNUAL_PRCP,
    PRCP,
    TEMP,
    START_YEAR_SIM,
    k1,
    ymax,
    dates.d,
    sim.dates.d,
    month.start = 1,
    knn.annual.sample.num = 50,
    wet.quantile = 0.2,
    extreme.quantile = 0.8,
    dry.spell.change = rep(1, 12),
    wet.spell.change = rep(1, 12),
    seed = NULL
) {

  if (!month.start %in% 1:12) stop("month.start must be in 1:12")
  water.year <- (month.start != 1)

  if (!is.null(seed)) {
    old_seed <- .Random.seed
    on.exit({ .Random.seed <<- old_seed }, add = TRUE)
    set.seed(seed + k1)
  }

  month_list <- if (month.start == 1) 1:12 else c(month.start:12, 1:(month.start - 1))

  dates_obs  <- dates.d$date
  months_obs <- dates.d$month
  days_obs   <- dates.d$day
  wyears_obs <- dates.d$wyear

  water_years_obs <- dates.d$wyear[dates.d$month == month.start & dates.d$day == 1]

  sim_length <- nrow(sim.dates.d)
  months_sim <- sim.dates.d$month
  days_sim   <- sim.dates.d$day
  wyears_sim <- sim.dates.d$wyear

  sim_prcp <- numeric(sim_length)
  sim_temp <- numeric(sim_length)
  sim_occ  <- integer(sim_length)
  sim_date <- as.Date(rep(NA, sim_length))

  rn_all <- runif(sim_length)

  k_annual <- max(
    round(sqrt(length(ANNUAL_PRCP))),
    round(length(ANNUAL_PRCP) * 0.5)
  )

  for (y in seq_len(ymax)) {

    # -------------------------------------------------
    # Set the simulated index for the first day of year y
    # -------------------------------------------------
    year_start_idx <- (y - 1L) * 365L + 1L
    if (year_start_idx > sim_length) break

    # -------------------------------------------------
    # Annual KNN: select observed years
    # -------------------------------------------------
    year_sample_idx <- knn_sample(
      candidates = ANNUAL_PRCP,
      target     = PRCP_FINAL_ANNUAL_SIM[y],
      k          = k_annual,
      n          = knn.annual.sample.num,
      prob       = TRUE,
      seed       = seed + k1 * y
    )

    cur_years <- water_years_obs[year_sample_idx]

    idx_by_year <- split(seq_along(wyears_obs), wyears_obs)
    obs_idx <- unlist(idx_by_year[as.character(cur_years)], use.names = FALSE)
    obs_idx <- obs_idx[!is.na(obs_idx)]

    prcp_y  <- PRCP[obs_idx]
    temp_y  <- TEMP[obs_idx]
    date_y  <- dates_obs[obs_idx]
    month_y <- months_obs[obs_idx]
    day_y   <- days_obs[obs_idx]
    wyear_y <- wyears_obs[obs_idx]

    # Month-day lookup (subset-specific)
    monthday_key_y <- paste(month_y, day_y, sep = ".")
    lookup_day_idx_y <- split(seq_along(monthday_key_y), monthday_key_y)

    # Monthly statistics
    mean_mon_PRCP <- tapply(prcp_y, month_y, mean)
    mean_mon_TEMP <- tapply(temp_y, month_y, mean)
    sd_mon_PRCP   <- tapply(prcp_y, month_y, sd)
    sd_mon_TEMP   <- tapply(temp_y, month_y, sd)

    mean_mon_PRCP[is.na(mean_mon_PRCP)] <- mean(prcp_y)
    mean_mon_TEMP[is.na(mean_mon_TEMP)] <- mean(temp_y)
    sd_mon_PRCP[is.na(sd_mon_PRCP) | sd_mon_PRCP == 0] <- sd(prcp_y)
    sd_mon_TEMP[is.na(sd_mon_TEMP) | sd_mon_TEMP == 0] <- sd(temp_y)

    # Thresholds aligned to month_list
    wet_thresh <- sapply(month_list, function(m) {
      vals <- prcp_y[month_y == m]
      if (!length(vals)) NA_real_ else quantile(vals, wet.quantile, names = FALSE)
    })
    extreme_thresh <- sapply(month_list, function(m) {
      vals <- prcp_y[month_y == m & prcp_y > 0]
      if (!length(vals)) NA_real_ else quantile(vals, extreme.quantile, names = FALSE)
    })

    wet_thresh[is.na(wet_thresh)] <- quantile(prcp_y, wet.quantile)
    extreme_thresh[is.na(extreme_thresh)] <- quantile(prcp_y[prcp_y > 0], extreme.quantile)

    # Markov probabilities (assumed fixed separately)
    probs <- calculateMarkovProbs(
      PRCP_LAG0 = prcp_y[-1],
      PRCP_LAG1 = prcp_y[-length(prcp_y)],
      MONTH_LAG0 = month_y[-1],
      MONTH_LAG1 = month_y[-length(prcp_y)],
      YEAR_LAG0  = wyear_y[-1],
      YEAR_LAG1  = wyear_y[-length(wyear_y)],
      wet_threshold = wet_thresh,
      extreme_threshold = extreme_thresh,
      month_list = month_list,
      MONTH_SIM = months_sim,
      WATER_YEAR_SIM = wyears_sim,
      y = y,
      START_YEAR_SIM = START_YEAR_SIM,
      dry.spell.change = dry.spell.change,
      wet.spell.change = wet.spell.change,
      SIM_LENGTH = sim_length
    )

    # -------------------------------------------------
    # FIRST DAY OF THIS SIM YEAR (critical)
    # Use the simulated calendar for that index
    # -------------------------------------------------
    first_month <- months_sim[year_start_idx]
    first_day   <- days_sim[year_start_idx]

    key0 <- paste(first_month, first_day, sep = ".")
    cand0 <- lookup_day_idx_y[[key0]]
    if (!length(cand0)) cand0 <- which(month_y == first_month)

    if (!length(cand0)) cand0 <- seq_along(prcp_y)

    i0 <- sample(cand0, 1)
    sim_prcp[year_start_idx] <- prcp_y[i0]
    sim_temp[year_start_idx] <- temp_y[i0]
    sim_occ[year_start_idx]  <- 0L
    sim_date[year_start_idx] <- date_y[i0]

    # -------------------------------------------------
    # DAILY LOOP: remaining 364 days of this year
    # -------------------------------------------------
    sim_idx <- year_start_idx

    for (j in 2:365) {

      sim_idx <- sim_idx + 1L
      if (sim_idx > sim_length) break
      prev_idx <- sim_idx - 1L

      sim_occ[sim_idx] <- markov_next_state(
        sim_occ[prev_idx],
        rn_all[prev_idx],
        prev_idx,
        probs$p00_final,
        probs$p01_final,
        probs$p10_final,
        probs$p11_final,
        probs$p20_final,
        probs$p21_final
      )

      cur_month <- months_sim[sim_idx]
      cur_day   <- days_sim[sim_idx]
      m_idx <- match(cur_month, month_list)
      if (is.na(m_idx)) m_idx <- 1L

      key <- paste(cur_month, cur_day, sep = ".")
      obs_candidates <- lookup_day_idx_y[[key]]
      if (!length(obs_candidates)) obs_candidates <- which(month_y == cur_month)

      if (!length(obs_candidates)) {
        sim_prcp[sim_idx] <- sim_prcp[prev_idx]
        sim_temp[sim_idx] <- sim_temp[prev_idx]
        sim_date[sim_idx] <- sim_date[prev_idx]
        next
      }

      obs_idx_window <- unique(as.vector(outer(obs_candidates, -3:3, "+")))
      obs_idx_window <- obs_idx_window[obs_idx_window > 0 & (obs_idx_window + 1) <= length(prcp_y)]

      if (!length(obs_idx_window)) {
        i <- sample(obs_candidates, 1)
        sim_prcp[sim_idx] <- prcp_y[i]
        sim_temp[sim_idx] <- temp_y[i]
        sim_date[sim_idx] <- date_y[i]
        next
      }

      state_idx <- get_state_indices(
        sim_occ[prev_idx],
        sim_occ[sim_idx],
        prcp_y,
        obs_idx_window,
        wet_thresh[m_idx],
        extreme_thresh[m_idx]
      )

      if (!length(state_idx)) {
        obs_idx_window <- unique(as.vector(outer(obs_candidates, -30:30, "+")))
        obs_idx_window <- obs_idx_window[obs_idx_window > 0 & (obs_idx_window + 1) <= length(prcp_y)]

        state_idx <- get_state_indices(
          sim_occ[prev_idx],
          sim_occ[sim_idx],
          prcp_y,
          obs_idx_window,
          wet_thresh[m_idx],
          extreme_thresh[m_idx]
        )
      }

      if (!length(state_idx)) {
        fb <- which(month_y == cur_month & (seq_along(prcp_y) + 1) <= length(prcp_y))
        if (!length(fb)) fb <- which((seq_along(prcp_y) + 1) <= length(prcp_y))
        i <- sample(fb, 1)
        sim_prcp[sim_idx] <- prcp_y[i]
        sim_temp[sim_idx] <- temp_y[i]
        sim_date[sim_idx] <- date_y[i]
        next
      }

      possible_days <- obs_idx_window[state_idx]

      if (!water.year) {
        possible_days <- possible_days[wyear_y[possible_days] == wyear_y[possible_days + 1]]
      }

      if (!length(possible_days)) {
        fb <- which(month_y == cur_month & (seq_along(prcp_y) + 1) <= length(prcp_y))
        if (!length(fb)) fb <- which((seq_along(prcp_y) + 1) <= length(prcp_y))
        i <- sample(fb, 1)
        sim_prcp[sim_idx] <- prcp_y[i]
        sim_temp[sim_idx] <- temp_y[i]
        sim_date[sim_idx] <- date_y[i]
        next
      }

      k_day <- max(1L, round(sqrt(length(possible_days))))

      next_days <- possible_days + 1L
      prcp_tomorrow <- prcp_y[next_days]
      temp_tomorrow <- temp_y[next_days]
      date_tomorrow <- date_y[next_days]

      cur_sim_prcp_anom <- sim_prcp[prev_idx] - mean_mon_PRCP[cur_month]
      cur_sim_temp_anom <- sim_temp[prev_idx] - mean_mon_TEMP[cur_month]

      prcp_today_anom <- prcp_y[possible_days] - mean_mon_PRCP[cur_month]
      temp_today_anom <- temp_y[possible_days] - mean_mon_TEMP[cur_month]

      weights <- c(100 / sd_mon_PRCP[cur_month], 10 / sd_mon_TEMP[cur_month])

      res <- knn_sample(
        candidates = cbind(prcp_today_anom, temp_today_anom),
        target     = c(cur_sim_prcp_anom, cur_sim_temp_anom),
        k          = k_day,
        n          = 1,
        prob       = TRUE,
        weights    = weights,
        seed       = seed + k1 * sim_idx
      )

      idx <- get_result_index(res, prcp_tomorrow)
      if (is.na(idx) || idx < 1L || idx > length(prcp_tomorrow)) {
        idx <- sample(seq_along(prcp_tomorrow), 1)
      }

      sim_prcp[sim_idx] <- prcp_tomorrow[idx]
      sim_temp[sim_idx] <- temp_tomorrow[idx]
      sim_date[sim_idx] <- date_tomorrow[idx]
    }
  }

  class(sim_date) <- "Date"
  sim_date
}



