{
  "hash": "db3ee8ceb778b26a5b167a30638f13b0",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Getting Started with weathergenr\"\ndescription: \"Read NetCDF inputs, generate stochastic realizations, and evaluate generator skill.\"\nformat:\n  html:\n    toc: true\n    toc-location: left\n    toc-title: \"Contents\"\n    toc-depth: 2\n    toc-expand: 2\n    page-layout: full\n    code-fold: true\n    code-tools: true\n    df-print: tibble\n    self-contained: true\nexecute:\n  echo: true\n  warning: false\n  message: false\n  cache: false\n  freeze: true\n  execute-dir: project\nvignette: >\n  %\\VignetteIndexEntry{Getting Started with weathergenr}\n  %\\VignetteEngine{quarto::html}\n  %\\VignetteEncoding{UTF-8}\n---\n\n# Introduction\n\nThe **weathergenr** package provides a comprehensive toolkit for stochastic weather generation and climate data analysis. It implements sophisticated statistical methods to create synthetic daily weather series that preserve the statistical properties of observed climate data while enabling scenario-based climate impact assessments.\n\nThis vignette demonstrates the core workflow:\n\n1. Reading gridded meteorological data from NetCDF files\n2. Generating synthetic weather realizations using coupled statistical methods  \n3. Evaluating the quality of synthetic weather against historical observations\n\n## Load Required Packages\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(weathergenr)\nlibrary(dplyr)\nlibrary(ggplot2)\n```\n:::\n\n\n::: {.callout-note}\n## Related functions\n\n- [`read_netcdf()`]\n- [`generate_weather()`]\n- [`evaluate_weather_generator()`]\n- [`write_netcdf()`]\n- [`apply_climate_perturbations()`]\n- [`analyze_wavelet_spectrum()`]\n:::\n\n\n\n\n# Reading Gridded Multivariate Weather Data\n\n## About the Example Dataset\n\nFor this tutorial, we use the ERA5 dataset (ECMWF Reanalysis v5) included with the package. The data covers the Ntoum Basin in Gabon, a tropical watershed in West Central Africa. The dataset includes daily precipitation, mean temperature, minimum temperature, and maximum temperature at a 0.25-degree spatial resolution.\n\n![Map of Ntoum Basin, Gabon](figures/ntoum_basin.png){width=\"65%\", fig-align=\"left\"}\n\n## Loading NetCDF Data\n\nThe `read_netcdf()` function provides an efficient interface for extracting meteorological data from NetCDF files. It handles the complexities of NetCDF format and returns data in a tidy, analysis-ready structure optimized for the weathergenr workflow.\n\n### Key Features\n\nThe function performs several important operations:\n\n- Extracts spatial coordinates and temporal information\n- Organizes data into per-grid-cell time series\n- Handles calendar systems including leap day management\n- Provides variable renaming capabilities\n- Optionally drops variables with all missing values to reduce memory usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Locate the example NetCDF file\nncfile <- system.file(\"extdata\", \"ntoum_era5_data.nc\", package = \"weathergenr\")\n\n# Read the NetCDF file with default settings\nncdata <- read_netcdf(ncfile)\n```\n:::\n\n\n### Understanding the Output Structure\n\nThe `read_netcdf()` function returns a list with five components that organize different aspects of the climate data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Display the top-level structure\nnames(ncdata)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data\"       \"grid\"       \"date\"       \"dimensions\" \"attributes\"\n```\n\n\n:::\n:::\n\n\n#### 1. Time Series Data\n\nThe `data` element contains a list of data frames, one for each grid cell. Each data frame represents a daily time series with columns for each meteorological variable:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Examine the first grid cell's time series\nhead(ncdata$data[[1]])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 7\n  press_msl   kin temp_min temp_max  temp  kout precip\n      <dbl> <dbl>    <dbl>    <dbl> <dbl> <dbl>  <dbl>\n1     1008.  174.     24.4     28.1  25.9  410.   9.12\n2     1008.  162.     23.7     28.1  24.9  410.  15.6 \n3     1008.  201.     23.6     27.9  25.6  411.   4.84\n4     1008.  177.     25.0     28.3  26.1  411.   5.20\n5     1007.  218.     24.6     28.1  26.1  411.   1.54\n6     1007.  199.     25.0     28.2  26.3  411.   8.35\n```\n\n\n:::\n:::\n\n\nThis structure allows efficient access to complete time series for individual locations while maintaining a compact memory footprint.\n\n#### 2. Spatial Grid Information\n\nThe `grid` element provides spatial metadata for each grid cell:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# View grid metadata\nhead(ncdata$grid)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 5\n     id  xind  yind         x         y\n  <int> <int> <int> <dbl[1d]> <dbl[1d]>\n1     1     1     1      9.5       0.5 \n2     2     2     1      9.75      0.5 \n3     3     3     1     10         0.5 \n4     4     1     2      9.5       0.25\n5     5     2     2      9.75      0.25\n6     6     3     2     10         0.25\n```\n\n\n:::\n:::\n\n\nEach row describes a grid cell with:\n\n- `id`: Sequential identifier for the grid cell\n- `xind`, `yind`: Array indices in the original NetCDF file\n- `x`, `y`: Spatial coordinates (longitude/latitude or projected coordinates)\n\n#### 3. Temporal Information\n\nThe `date` element contains the complete time axis as a vector of Date objects:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Display the first and last few dates\nhead(ncdata$date)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2000-01-01\" \"2000-01-02\" \"2000-01-03\" \"2000-01-04\" \"2000-01-05\"\n[6] \"2000-01-06\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntail(ncdata$date)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2020-12-26\" \"2020-12-27\" \"2020-12-28\" \"2020-12-29\" \"2020-12-30\"\n[6] \"2020-12-31\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Confirm the total number of days\nlength(ncdata$date)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7671\n```\n\n\n:::\n:::\n\n\n#### 4. Dimension Vectors\n\nThe `dimensions` element stores the raw dimension vectors from the NetCDF file:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# View available dimensions\nnames(ncdata$dimensions)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"longitude\" \"latitude\"  \"time\"     \n```\n\n\n:::\n:::\n\n\n#### 5. Metadata Attributes\n\nThe `attributes` element preserves variable attributes, spatial reference information, and global metadata from the NetCDF file, ensuring traceability and documentation.\n\n### Advanced Usage\n\nThe `read_netcdf()` function supports several optional parameters for customized data loading:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example: Load specific variables and rename them\nncdata <- read_netcdf(\n  nc_path = ncfile,\n  var = c(\"precip\", \"temp\"),\n  var_name = c(precip = \"precipitation\", temp = \"temperature\")\n)\n\n# Example: Handle 365-day calendar data (no leap days)\nncdata <- read_netcdf(\n  nc_path = ncfile,\n  keep_leap_day = FALSE\n)\n\n# Example: Round values to reduce precision and memory\nncdata <- read_netcdf(\n  nc_path = ncfile,\n  signif_digits = 4,\n  drop_all_na = TRUE\n)\n```\n:::\n\n\n# Generating Stochastic Weather Realizations\n\n## Overview of the Weather Generation Method\n\nThe `generate_weather()` function implements a sophisticated multi-scale weather generation framework that combines several statistical methods:\n\n### Statistical Components\n\n1. **Wavelet Autoregressive Modeling (WARM)**: Captures low-frequency (annual to multi-year) climate variability by decomposing annual precipitation signals into wavelet components and simulating their temporal evolution using ARIMA models.\n\n2. **Markov Chain Model**: Controls the persistence of wet and dry spells at the daily scale by modeling transitions between three precipitation states (dry, wet, extreme) with monthly-varying transition probabilities.\n\n3. **K-Nearest Neighbors (KNN) Resampling**: Selects historical analogue years based on similarity in annual precipitation patterns and resamples daily weather sequences from these analogues while preserving spatial and temporal correlations.\n\nThis coupled approach ensures that synthetic weather series preserve both:\n\n- **Temporal structure**: Day-to-day persistence, seasonal cycles, and interannual variability\n- **Spatial coherence**: Correlations between grid cells and co-occurrence patterns of weather events\n- **Statistical properties**: Means, variances, extremes, and distributional characteristics\n\nThe method is described in detail by [Steinschneider and Brown (2013)](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1002/wrcr.20528).\n\n## Setting Up the Simulation\n\nFirst, define the output directory and specify which meteorological variables to simulate:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a temporary directory for outputs\noutput_dir <- tempdir()\n\n# Define variables to simulate\nvariables <- c(\"precip\", \"temp\", \"temp_min\", \"temp_max\")\n\n# Labels for plotting (optional)\nvariable_labels <- c(\"Precipitation\", \"Temperature (mean)\", \n                     \"Temperature (min)\", \"Temperature (max)\")\n\n# Number of stochastic realizations to generate\nrealization_num <- 3\n```\n:::\n\n\n### Understanding Simulation Parameters\n\nKey parameters control different aspects of the weather generation:\n\n- **Temporal scope**: `n_years` and `start_year` define the simulation period\n- **Realization count**: `n_realizations` specifies how many independent synthetic series to create\n- **WARM parameters**: Control annual-scale variability simulation\n  - `warm_var`: The primary driver variable (typically precipitation)\n  - `warm_signif`: Significance threshold for retaining wavelet components (0.90 = 90% confidence)\n  - `warm_pool_size`: Number of candidate annual traces to generate before filtering\n- **KNN parameters**: Control daily-scale resampling\n  - `annual_knn_n`: Number of historical analogue years to consider\n- **Markov Chain parameters**: Define precipitation state thresholds\n  - `wet_q`: Threshold for wet day classification (0.3 = 30th percentile)\n  - `extreme_q`: Threshold for extreme precipitation (0.8 = 80th percentile)\n\n## Running the Weather Generator\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set a seed for reproducibility\nseed <- 123\n\n# Generate synthetic weather series\nstochastic_weather <- generate_weather(\n  obs_data = ncdata$data,\n  obs_grid = ncdata$grid,\n  obs_dates = ncdata$date,\n  vars = variables,\n  n_years = 20,\n  start_year = 2020,\n  year_start_month = 1,\n  n_realizations = realization_num,\n  warm_var = \"precip\",\n  warm_signif = 0.90,\n  warm_pool_size = 10000,\n  annual_knn_n = 100,\n  wet_q = 0.2,\n  extreme_q = 0.8,\n  out_dir = output_dir,\n  seed = seed,\n  parallel = FALSE,\n  n_cores = NULL,\n  verbose = FALSE\n)\n```\n:::\n\n\n### Understanding the Output\n\nThe function returns a list containing:\n\n- `resampled`: The historical dates selected as analogues for each simulation day\n- `dates`: The simulated daily time axis (always 365-day calendar, Feb 29 excluded)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# View the structure of the output\nnames(stochastic_weather)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"resampled\" \"dates\"    \n```\n\n\n:::\n\n```{.r .cell-code}\n# Check the simulated date range\nhead(stochastic_weather$dates)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2020-01-01\" \"2020-01-02\" \"2020-01-03\" \"2020-01-04\" \"2020-01-05\"\n[6] \"2020-01-06\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntail(stochastic_weather$dates)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2039-12-26\" \"2039-12-27\" \"2039-12-28\" \"2039-12-29\" \"2039-12-30\"\n[6] \"2039-12-31\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Examine resampled dates for the first realization\nhead(stochastic_weather$resampled[[1]])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2016-01-01\" \"2016-01-02\" \"2016-01-01\" \"2016-01-02\" \"2016-01-03\"\n[6] \"2016-01-04\"\n```\n\n\n:::\n:::\n\n\n### Interpreting Resampled Dates\n\nThe resampled dates show which historical days were selected as analogues. This information reveals:\n\n- Whether the generator is drawing from wet or dry historical periods\n- The diversity of historical conditions being sampled\n- Temporal clustering patterns in the resampling scheme\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Display resampled dates for all realizations\nstochastic_weather$resampled\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7,300 × 3\n   rlz_1      rlz_2      rlz_3     \n   <date>     <date>     <date>    \n 1 2016-01-01 2018-01-01 2011-01-01\n 2 2016-01-02 2018-01-03 2011-01-03\n 3 2016-01-01 2002-01-01 2011-01-07\n 4 2016-01-02 2002-01-02 2011-01-08\n 5 2016-01-03 2002-01-03 2011-01-05\n 6 2016-01-04 2002-01-07 2011-01-06\n 7 2006-01-07 2002-12-31 2011-01-07\n 8 2015-01-09 2000-01-06 2011-01-10\n 9 2015-01-07 2000-01-07 2011-01-13\n10 2011-01-09 2000-01-08 2011-01-09\n# ℹ 7,290 more rows\n```\n\n\n:::\n:::\n\n\n## Extracting Synthetic Weather Data\n\nTo access the actual weather values (not just the resampled dates), you need to extract the corresponding data from the historical record:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example: Extract synthetic weather for all realizations\nsynthetic_data <- list()\n\nfor (i in 1:realization_num) {\n  # Get the day order for this realization\n  day_order <- match(stochastic_weather$resampled[[i]], ncdata$date)\n  \n  # Extract corresponding weather data for each grid cell\n  synthetic_data[[i]] <- lapply(ncdata$data, function(cell_data) {\n    cell_data[day_order, variables] %>%\n      mutate(date = stochastic_weather$dates, .before = 1)\n  })\n}\n```\n:::\n\n\n# Evaluating Synthetic Weather Series\n\n## Purpose of Evaluation\n\nValidating the weather generator's performance is crucial to ensure that synthetic weather series are suitable for impact modeling. The `evaluate_weather_generator()` function provides comprehensive diagnostic comparisons between simulated and observed weather across multiple statistical dimensions.\n\n## Preparing Data for Evaluation\n\nThe evaluation function requires:\n\n1. Observed weather data in list format (one element per grid cell)\n2. Simulated weather data structured similarly\n3. Matching date columns in both datasets\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create day order indices for each realization\nday_order <- sapply(\n  1:realization_num,\n  function(n) match(stochastic_weather$resampled[[n]], ncdata$date)\n)\n\n# Extract synthetic weather samples\nrlz_sample <- list()\nfor (n in 1:realization_num) {\n  rlz_sample[[n]] <- lapply(ncdata$data[ncdata$grid$id], function(x) {\n    x[day_order[, n], ] %>%\n      select(precip, temp, temp_min, temp_max) %>%\n      mutate(date = stochastic_weather$dates, .before = 1)\n  })\n}\n\n# Prepare observed data\nobs_sample <- lapply(ncdata$data[ncdata$grid$id], function(x) {\n  x %>%\n    select(precip, temp, temp_min, temp_max) %>%\n    mutate(date = ncdata$date, .before = 1)\n})\n```\n:::\n\n\n## Running the Evaluation\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Evaluate weather generator performance\nevaluation_plots <- evaluate_weather_generator(\n  daily_sim = rlz_sample,\n  daily_obs = obs_sample,\n  variables = variables,\n  variable_labels = variable_labels,\n  n_realizations = realization_num,\n  wet_quantile = 0.3,\n  extreme_quantile = 0.8,\n  output_dir = NULL,\n  save_plots = FALSE\n)\n```\n:::\n\n\n## Understanding Evaluation Metrics\n\nThe evaluation function computes and visualizes several key aspects of weather generator performance:\n\n### 1. Daily Statistics\n\nComparison of mean, standard deviation, and skewness for each variable across all grid cells. This assesses whether the generator preserves the central tendency, variability, and distributional shape of observed weather.\n\n### 2. Wet and Dry Day Frequencies\n\nFor precipitation, the evaluation examines:\n\n- Total number of wet days (above the wet threshold)\n- Number of extreme precipitation days (above the extreme threshold)\n- Dry day frequencies\n\nThese metrics reveal whether the generator correctly reproduces precipitation occurrence patterns.\n\n### 3. Spell Length Distributions\n\nAnalysis of consecutive wet and dry periods:\n\n- Mean wet spell length\n- Mean dry spell length\n- Distribution of spell durations\n\nThis assesses the generator's ability to capture persistence in weather patterns.\n\n### 4. Spatial Correlations\n\nInter-site correlation matrices for each variable, comparing observed versus simulated spatial coherence. This is critical for applications requiring realistic spatial patterns (e.g., regional hydrology).\n\n## Viewing Evaluation Results\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Display all diagnostic plots\nevaluation_plots\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$daily_mean\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](getting_started_files/figure-html/view_evaluation-1.png){width=960}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n$daily_sd\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](getting_started_files/figure-html/view_evaluation-2.png){width=960}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n$spell_length\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](getting_started_files/figure-html/view_evaluation-3.png){width=960}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n$wetdry_days_count\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](getting_started_files/figure-html/view_evaluation-4.png){width=960}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n$crossgrid\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](getting_started_files/figure-html/view_evaluation-5.png){width=960}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n$intergrid\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](getting_started_files/figure-html/view_evaluation-6.png){width=960}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n$precip_cond_cor\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](getting_started_files/figure-html/view_evaluation-7.png){width=960}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n$annual_pattern_precip\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](getting_started_files/figure-html/view_evaluation-8.png){width=960}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n$annual_pattern_temp\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](getting_started_files/figure-html/view_evaluation-9.png){width=960}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n$annual_pattern_temp_min\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](getting_started_files/figure-html/view_evaluation-10.png){width=960}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n$annual_pattern_temp_max\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](getting_started_files/figure-html/view_evaluation-11.png){width=960}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n$monthly_cycle\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](getting_started_files/figure-html/view_evaluation-12.png){width=960}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n$annual_precip\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](getting_started_files/figure-html/view_evaluation-13.png){width=960}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nattr(,\"class\")\n[1] \"weather_assessment\" \"list\"              \nattr(,\"fit_summary\")\n# A tibble: 3 × 17\n  rlz    rank overall_score mae_mean_precip mae_mean_temp mae_mean_temp_max\n  <chr> <int>         <dbl>           <dbl>         <dbl>             <dbl>\n1 3         1         0.345            2.65          17.0              19.2\n2 2         2         0.522            2.67          17.0              19.2\n3 1         3         0.643            2.66          17.0              19.2\n# ℹ 11 more variables: mae_mean_temp_min <dbl>, mae_sd_precip <dbl>,\n#   mae_sd_temp <dbl>, mae_sd_temp_max <dbl>, mae_sd_temp_min <dbl>,\n#   mae_days_Dry <dbl>, mae_days_Wet <dbl>, mae_spell_Dry <dbl>,\n#   mae_spell_Wet <dbl>, mae_cor_crossgrid <dbl>, mae_cor_intervariable <dbl>\nattr(,\"metadata\")\nattr(,\"metadata\")$n_grids\n[1] 6\n\nattr(,\"metadata\")$n_realizations\n[1] 3\n\nattr(,\"metadata\")$variables\n[1] \"precip\"   \"temp\"     \"temp_min\" \"temp_max\"\n\nattr(,\"metadata\")$assessment_date\n[1] \"2026-01-21\"\n```\n\n\n:::\n:::\n\n\n### Interpreting the Plots\n\nGood weather generator performance is indicated by:\n\n- **Scatter plots near the 1:1 line**: Simulated statistics closely match observed values\n- **Overlapping distributions**: Similar shapes and ranges between observed and simulated\n- **Consistent correlation patterns**: Spatial correlations preserved in synthetic data\n- **Balanced residuals**: No systematic bias in any direction\n\nDiscrepancies may indicate:\n\n- Parameter tuning needed - adjust WARM or Markov chain thresholds\n- Insufficient historical analogue pool - increase KNN sample size\n- Structural limitations for specific climate regimes\n\n# Other Features\n\nThe weathergenr package supports additional capabilities not covered in this basic tutorial:\n\n## Climate Scenario Analysis\n\nUse `apply_climate_perturbations()` to modify synthetic weather based on climate change scenarios:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example: Apply temperature increase and precipitation changes\ngrid_with_lat <- ncdata$grid\ngrid_with_lat$lat <- grid_with_lat$y\n\nperturbed_weather <- apply_climate_perturbations(\n  data = synthetic_data[[1]],\n  grid = grid_with_lat,\n  date = stochastic_weather$dates,\n  precip_mean_factor = rep(1.1, 12),\n  precip_var_factor = rep(1.0, 12),\n  temp_delta = rep(2.0, 12),\n  temp_transient = FALSE,\n  precip_transient = FALSE,\n  compute_pet = FALSE\n)\n```\n:::\n\n\n## Wavelet Spectral Analysis\n\nExplore low-frequency climate variability using wavelet transforms:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Analyze spectral characteristics of annual precipitation\nwavelet_results <- analyze_wavelet_spectrum(\n  series = annual_precip,\n  signif = 0.90,\n  noise = \"red\",\n  min_period = 2,\n  detrend = FALSE,\n  mode = \"fast\"\n)\n```\n:::\n\n\n## Parallel Computing\n\nFor large spatial domains, enable parallel processing to accelerate computation:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Generate weather using multiple cores\nstochastic_weather <- generate_weather(\n  # ... other parameters ...\n  parallel = TRUE,\n  n_cores = 4\n)\n```\n:::\n\n\n## Saving and Exporting Results\n\nResults can be written back to NetCDF format for use in other tools:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example: Write synthetic weather to NetCDF\ndata_to_write <- lapply(synthetic_data[[1]], function(df) {\n  as.list(df[variables])\n})\n\nwrite_netcdf(\n  data = data_to_write,\n  grid = ncdata$grid,\n  out_dir = output_dir,\n  origin_date = stochastic_weather$dates[1],\n  calendar = \"noleap\",\n  template_path = ncfile,\n  file_prefix = \"synthetic_weather\",\n  file_suffix = \"rlz1\"\n)\n```\n:::\n\n\n# Further Reading\n- **Methodological details**: See Steinschneider and Brown (2013) for the theoretical foundation\n- **Package documentation**: Use `?function_name` to access detailed help for any function\n\n---\n\n**Session Information**\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\nR version 4.5.2 (2025-10-31 ucrt)\nPlatform: x86_64-w64-mingw32/x64\nRunning under: Windows 11 x64 (build 26200)\n\nMatrix products: default\n  LAPACK version 3.12.1\n\nlocale:\n[1] LC_COLLATE=English_United States.utf8 \n[2] LC_CTYPE=English_United States.utf8   \n[3] LC_MONETARY=English_United States.utf8\n[4] LC_NUMERIC=C                          \n[5] LC_TIME=English_United States.utf8    \n\ntime zone: Europe/Amsterdam\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] ggplot2_4.0.1     dplyr_1.1.4       weathergenr_1.0.1\n\nloaded via a namespace (and not attached):\n [1] utf8_1.2.6         generics_0.1.4     tidyr_1.3.2        class_7.3-23      \n [5] lattice_0.22-7     digest_0.6.39      magrittr_2.0.4     evaluate_1.0.5    \n [9] grid_4.5.2         RColorBrewer_1.1-3 iterators_1.0.14   fastmap_1.2.0     \n[13] foreach_1.5.2      jsonlite_2.0.0     e1071_1.7-17       nnet_7.3-20       \n[17] forecast_9.0.0     purrr_1.2.1        viridisLite_0.4.2  scales_1.4.0      \n[21] isoband_0.3.0      textshaping_1.0.4  codetools_0.2-20   cli_3.6.5         \n[25] rlang_1.1.7        withr_3.0.2        yaml_2.3.12        otel_0.2.0        \n[29] tools_4.5.2        parallel_4.5.2     ncdf4_1.24         colorspace_2.1-2  \n[33] curl_7.0.0         vctrs_0.6.5        R6_2.6.1           zoo_1.8-15        \n[37] proxy_0.4-29       lifecycle_1.0.5    tseries_0.10-59    ragg_1.5.0        \n[41] urca_1.3-4         pkgconfig_2.0.3    pillar_1.11.1      gtable_0.3.6      \n[45] quantmod_0.4.28    glue_1.8.0         Rcpp_1.1.1         systemfonts_1.3.1 \n[49] xfun_0.55          tibble_3.3.1       lmtest_0.9-40      tidyselect_1.2.1  \n[53] rstudioapi_0.18.0  knitr_1.51         farver_2.1.2       nlme_3.1-168      \n[57] htmltools_0.5.9    patchwork_1.3.2    labeling_0.4.3     xts_0.14.1        \n[61] rmarkdown_2.30     timeDate_4051.111  fracdiff_1.5-3     compiler_4.5.2    \n[65] quadprog_1.5-8     S7_0.2.1           TTR_0.24.4        \n```\n\n\n:::\n:::\n\n",
    "supporting": [
      "getting_started_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}